// -*- coding: utf-8 -*-
= LISP1.5 implementation on Gauche
:sectnums:
:toc:
:toc-placement!:
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

This is a fun project to implement LISP 1.5 as described in
"LISP 1.5 Programmer's Manual".  It's not a complete LISP 1.5 environment
emulator; instead, it is to get a glimpse of how it is constructed.

toc::[]


== M-expressions

Back then, M-expression was for human to write and read programs on paper,
but you had to manually translate it to S-expression then punch the cards.
Now you can make the computer understand M-expression directly!

=== M-expression syntax summary

- Identifiers are in all lowercase.  Literal symbols are in all uppercase.
  No `quote` in M-expression.  Literal list can be written using parentheses,
  e.g. `(A B (C D . E))`, without a quote.
- Function call is written as `fn[arg1;arg2;...]`
- Conditional is `[test1 \-> expr1; test2 \-> expr2;...]`.  It works just like
  `cond`.   Unicode arrow character `->` (U+2192) can be used in place of `\->`.
- Symbol `NIL` is used for list terminator.  Hence `cons[A;NIL]` yields
  `(A)`.
- Literal function is written as `lambda[[arg;..];expr]`.  This lambda form
itself doesn't have a value -- it must be called with arguments to take effect.
- Local recursive function can be written as `label[name;lambda[[arg;...];expr]]`,
where you can use `name` in the `expr` to refer to itself.
- In toplevel, you can define a function by `name[arg;...] = expr`.

We also add this extension:

- A hash sign `#` to the end of line is a comment.  We avoid `;`, for
  it is used as a separator.


=== Calling M-expression parser

Module `LISP1.5.mexpr` implements parsers.  A procedure
`parse-mexpr` takes a string or an input port, and parses one M-expression
and returns an S-expression.

----
gosh> ,u LISP1.5.mexpr
gosh> (parse-mexpr "cons[(A . B);C]")
(CONS (QUOTE (A . B)) (QUOTE C))
----

Uppercase names and lists in M-expression are literals,
hence they are `QUOTE`-{nbsp}d once parsed.

If the input may contain more than one M-expression, use `parse-mexprs`
instead, which reads input up to EOF and returns an lseq of result
S-expressions.


=== Writing source in M-expression:

You can write M-expression in Scheme source code using `#!m-expr` directive.

----
;;
;; Scheme comments
;; 
(use LISP1.5.mexpr)
#!m-expr

# M-expression function definitions
function1[arg;...] = expression1
function2[arg;...] = expression2
...
----

The `#!m-expr` directive translates those M-expressions into
a LISP1.5 `DEFINE` form:

----
(DEFINE
 ((FUNCTION1 (LAMBDA (ARG ...) EXPRESSION1))
  (FUNCTION2 (LAMBDA (ARG ...) EXPRESSION2))
  ...))
----

Note that you have to have definitions of `DEFINE` and other primitive
LISP1.5 forms before loading the source file; The `LISP1.5.mexpr` module
only handles parsing.

We provide several implementations of those LISP1.5 primitives,
which we'll show you in the following chapters.


== A Universal LISP Function

=== Running EVAL with minimal axioms

Section 1.6 of "LISP 1.5 Programmer's Manual" is one of the pinnacles
of the document.  They show how to implement Lisp interpreter
on top of Lisp systems.  They call it "a Universal LISP function".

We write out their code in link:mx/eval.mx[].

What's interesting about it is that you only need a handful of
functions and syntaxes to run the interpreter.  We define those
minimal set of primitives in link:LISP1/5/axioms.scm[].
It provides the definition of the following primitives:
`CAR`, `CDR`, `CONS`, `ATOM`, `EQ`, `QUOTE`, `COND`, and `DEFINE`.

To try the eval function, first `use` the axioms module, then
load the `eval.mx` file.  Assuming you have
load path set to the top directory of LISP1.5 source,
you can say the following in the gosh REPL:

----
gosh> ,u LISP1.5.axioms
gosh> ,l mx/eval.mx
#t
----

Or, you can start gosh with loading necessary modules
(this assumes you're in the top directory of LISP1.5 source):

----
$ gosh -I. -u LISP1.5.axioms -l mx/eval.mx
----

On the gosh prompt, you can call `EVAL`.  The first argument
is the S-expression to evaluate, and the second argument
is the environment (assoc list of symbols and values):

----
gosh> (EVAL '(CONS (CAR (QUOTE (X . Y))) (QUOTE Z)) 'NIL)
(X . Z)
----

Be aware of the difference of `'` (`quote`) and `QUOTE`.
The former one is recognized by Gauche.  The latter one is recognized by
`EVAL`.

If you prefer, you can write M-expressions using
read-time constructor `#,(m-expr "...")`:

----
gosh> (EVAL '#,(m-expr "cons[car[(X . Y)];Z]") 'NIL)
(X . Z)
----

Following is a bit more convoluted example.  It defines `append`
as a recursive funciton using `LABEL`, and calls it with
two arguments, `(A B C)` and `(X Y Z)`:


----
gosh> (EVAL '#,(m-expr "label[append;lambda[[xs;r];\
                               [eq[xs;NIL] -> r;\
                                T -> cons[car[xs];append[cdr[xs];r]]]]]\
                        [(A B C);(X Y Z)]")
            'NIL)
(A B C X Y Z)
----

This interpreter only _knows_ the minimal 7 primitives:
`CAR`, `CDR`, `CONS`, `ATOM`, `EQ`, `QUOTE`, and `COND`.
To refer to anything other than that, 
you have to pass them in the environment argument.

The following example reverses a list, using the
definition of `NULL`, `APPEND` and `REVERSE` given to the environment:

----
gosh> (EVAL '#,(m-expr "reverse[(A B C D E F G)]")
            '((NULL . #,(m-expr "lambda[[x];[eq[x;NIL] -> T; T -> F]]"))
              (APPEND . #,(m-expr "lambda[[xs;r];\
                                     [eq[xs;NIL] -> r;\
                                      T -> cons[car[xs];append[cdr[xs];r]]]]"))
              (REVERSE . #,(m-expr "lambda[[xs];\
                                      [null[xs] -> NIL;\
                                       T -> append[reverse[cdr[xs]];cons[car[xs];NIL]]]]"))
             ))
(G F D C B A)
----

[NOTE]
================================================================
We need to provide the function `NULL` in the environment, 
since the one defined in `eval.mx` exists in the world of Gauche, and is
not visible from the world of `EVAL`.
================================================================

[TIP]
================================================================
When you refer to an identifier that's neither one of the built-in
primitive nor the one given in the environment, you'll get an error
like the following:

----
*** ERROR: pair required, but got NIL
Stack Trace:
_______________________________________
  0  (car x)
        at "./LISP1/5/axioms.scm":9
  1  (CAR X)
        [unknown location]
  2  (CAAR A)
        [unknown location]
  3  (EQUAL (CAAR A) X)
        [unknown location]
  4  (ASSOC E A)
        [unknown location]
  5  (EVAL FN A)
        [unknown location]
...
----

The code searches the environment alist by `ASSOC`, hits the end of
the alist without finding it and complains.  Remember, we have minimal
interpreter and there's no fancy error handling mechanism.
================================================================


=== Going Metacircular

Since the universal LISP function defined in `eval.mx` understands
the primitives required to interpret functions in `eval.mx`, you can use
our `EVAL` to evaluate `eval.mx` to run `EVAL` on top of 
`EVAL` -- now you're running a metacircular interpreter!

You might have noticed though, that `axioms.scm` provides `DEFINE`,
which is missing in `eval.mx`.  In our context of discussing
metacircular interpreter, `DEFINE` appears as a result of
parsing M-expression definitions, and should be understood
as a meta-language to direct the set-up, rather than an integrated
part of the language (one way to think of it is that if other primitives
are C built-ins then `DEFINE` is `#pragma` or `Makefile` -- they belong
to a slightly different layer.)

Of course, it is more convenient to include `DEFINE` in the core language,
and we'll deal with it later.  For now, let's stick to the primitives
excluding `DEFINE`.

In order to run `EVAL` inside `EVAL`, we need to prepare the definitions
in `eval.mx` as an environment alist passed to outer `EVAL`.
Run the following command in the toplevel source directory:

----
$ gosh tools/mexpr-env.scm mx/eval.mx
----

It reads `eval.mx` and prints the definitions in an alist.  Copy the output,
then start `gosh` again, read `axioms` and load `eval.mx`, and evaluate
the `EVAL` expression, passing the copied alist as the environment
(don't forget the quote before the alist!):


----
gosh> ,u LISP1.5.axioms
gosh> ,l mx/eval.mx
#t
gosh> (EVAL '(EVAL (QUOTE (CAR (QUOTE (X . Y)))) (QUOTE NIL))
            '...<<here, copy & paste the output of mexpr-env.scm>>)
X
----

The result `X` is the result of `(CAR (QUOTE (X . Y)))`, computed
by the `EVAL` function implemented in LISP1.5, not the underlying Gauche.

If cut&pasting the environment alist is too tedious, `mexpr-env.scm` can
create a definition of an auxiliary function `EVAL*`, which calls `EVAL`
with the environment that has all the definitions in the given source file.
Run `mexpr-env.scm` with `-e` option, and save the result in `lisp/eval.lisp`:

----
$ gosh tools/mexpr-env.scm -e mx/eval.mx > lisp/eval.lisp
----

[TIP]
==================================================================
Instead of manually executing `tools/mexpr-env.scm`, you can
run the standard build process (`./configur && make`) and
all the converted files are placed under `lisp/`.
==================================================================


We use suffix `lisp` to indicate it is not a Scheme code (even though
Gauche can understand it after using `LISP1.5.axioms`).
The created `lisp/eval.lisp` looks as follows:

----
(DEFINE ((EVAL* (LAMBDA (X) (EVAL X '...<<environment defined in eval.mx>>...
)))))
----

That is, it defines `EVAL*` which takes one LISP1.5 expression and
evaluates it under the enviornment where all the definitions in `eval.mx`
is visible.

The created `eval.lisp` can be loaded to `gosh` after using `LISP1.5.axioms`.  
Together with `mx/eval.mx`, you can run `EVAL` on top of `EVAL`:

----
$ gosh -I. -uLISP1.5.axioms -lmx/eval.mx -leval-star.lisp
gosh> (EVAL* '#,(m-expr"eval[(CONS (QUOTE X) (QUOTE Y));NIL]"))
(X . Y)
----

This time we used M-expression in the inner call.  It's the same
as writing `'(EVAL (QUOTE (CONS (QUOTE X) (QUOTE Y))) (QUOTE NIL))`.

Let's recap what's happening.  The outer `EVAL` (via `EVAL*`) is
executed by Gauche, using the initially loaded `eval.mx`.  The
inner `EVAL` is interpreted by the outer `EVAL`, using the
enviornment created by `mexpr-env.scm`.
And the expression `(CONS (QUOTE X) (QUOTE Y))` is interpreted by
the inner `EVAL`:

----
        +----------------------------+
        | (CONS (QUOTE X) (QUOTE Y)) |
        +----------------------------+
        |           EVAL             |  ; inner EVAL
        +----------------------------+
        |           EVAL             |  ; outer EVAL
        +----------------------------+
        |          Gauche            |
        +----------------------------+
----

If it is not obvious, try it with an altered environment.
For example, edit the `eval.lisp` created above
to change the inner `EVAL` recognizes `KWOTE` instead of `QUOTE`.
There's only one place to change:

----
 (EVAL
  LAMBDA
  (E A)
  (COND
   ((ATOM E) (CDR (ASSOC E A)))
   ((ATOM (CAR E))
    (COND ((EQ (CAR E) (QUOTE KWOTE)) (CADR E))
                              ^^^^^
     ((EQ (CAR E) (QUOTE COND)) (EVCON (CDR E) A))
     ((QUOTE T) (APPLY (CAR E) (EVLIS (CDR E) A) A))))
   ((QUOTE T) (APPLY (CAR E) (EVLIS (CDR E) A) A))))
----

(Leave other `QUOTE` intact, for they are recognized by the outer `EVAL`).

Now, try it:

----
(EVAL* '(EVAL (QUOTE (CONS (KWOTE X) (KWOTE Y))) (QUOTE NIL)))
  => (X . Y)
----

The two `QUOTE`{nbsp}s are recognized by the outer `EVAL`, and the two
`KWOTE`{nbsp}s are recognized by the inner `EVAL`.  Furthermore,
the `'` (`quote`) is recognized by Gauche.


=== Having FUN with ARG

(If you know what we'll talk about from the section title, you can
skip this section.  Yes, it's just about _that_.)

One advantage of having a simple language with a concise interpreter is
that we can tweak it easily.

In the universal `EVAL`, a function is represented as a literal list
whose car is `LAMBDA`.  It is a powerful idea--now you can have
a function as a first-class citizen of the language, that you can
construct it, pass it to another function, and return it from another
funciton.  However, it has a flaw.

Let's try a failure case and see if we can fix it.

Consider `MAPCAR` function, which takes a function and a list, and
returns a list of results of the function applied to each element of the
given list (that is, Scheme's `map` function):

----
mapcar[fn;x] = [null[x] -> NIL;
                T -> cons[fn[car[x]];mapcar[fn;cdr[x]]]]
----

It is in link:mx/mapcar.mx[].  You can't load it directly
into Gauche, however.  Treating a list starting with `LAMBDA` as
a function is a feature of `EVAL`, not Gauche.  
We have to make `EVAL` understand the above definition.

We can use the same technique we used in the metacircular interpreter --
that is, translate the definition of `MAPCAR` above into an enviroment
alist.  We also need the definition of `NULL`, so let's combine
`eval.mx` together with `mapcar.mx`.  It can be done with the following
command line:

----
$ gosh tools/mexpr-env.scm -e mx/eval.mx mx/mapcar.mx > lisp/mapcar.lisp
----

Alternatively, run `./configure` then `make` in the toplevel source directory.

Once you have `lisp/mapcar.lisp`, you can load it (after `mx/eval.mx`)
and you can call `MAPCAR` inside `EVAL*`:

----
$ gosh -I. -uLISP1.5.axioms
gosh> ,l mx/eval.mx
#t
gosh> ,l lisp/mapcar.lisp
#t
gosh> (EVAL* '(MAPCAR (QUOTE (LAMBDA (X) (CONS X (QUOTE Y)))) (QUOTE (A B C))))
((A . Y) (B . Y) (C . Y))
gosh> (EVAL* '#,(m-expr "mapcar[(LAMBDA (X) (CONS X (QUOTE Y)));(A B C)]"))
((A . Y) (B . Y) (C . Y))
----

So far, so good.

Now, Let's try nesting `MAPCAR`.  We'll do equivalent to the following
Scheme code:

----
(map (lambda (x) (map (lambda (y) (cons x y)) '(p q r))) '(a b c))
  => (((a . p) (a . q) (a . r)) ((b . p) (b . q) (b . r)) ((c . p) (c . q) (c . r)))
----

Here's LISP1.5 version:

----
(EVAL* '(MAPCAR (QUOTE (LAMBDA (X)
                         (MAPCAR (QUOTE (LAMBDA (Y) (CONS X Y)))
                                 (QUOTE (P Q R)))))
                (QUOTE (A B C))))
  => ((((P Q R) . P) ((Q R) . Q) ((R) . R)) (((P Q R) . P) ((Q R) . Q) ((R) . R)) (((P Q R) . P) ((Q R) . Q) ((R) . R)))
----

Oops, what happened?  Let's examine the details.
Outer `MAPCAR` receives two actual parameters, `(LAMBDA (X) ...)` and `(A B C)`
(`QUOTE`{nbsp}s are stripped when arguments are evaluated
by `evlis` before calling the function).   They are bound to the
local parameters, `FN` and `X`, respectively.  In other words,
the body of `MAPCAR`:

----
[null[x] -> NIL;
 T -> cons[fn[car[x]];mapcar[fn;cdr[x]]]]
----

is evaluated with the following environment:

----
((FN . (LAMBDA (X)
         (MAPCAR (QUOTE (LAMBDA (Y) (CONS X Y)))
                 (QUOTE (P Q R)))))
 (X . (A B C)))
----

Since `X` is not `NIL`, evaluation goes to `cons[...]` branch.
The first argument is `fn[car[x]]`, so first `car[x]` is evaluated
and yields `A`, `fn` evaluated to the outer `LAMBDA` form
and we call it with `A`.  The body of inner `LAMBDA` form, which
is the inner `MAPCAR` call, is evaluated with the following environment
(Keep in mind that the new local bindings are inserted in front of
outer environment):

----
((X . A)
 (FN . (LAMBDA (X)
         (MAPCAR (QUOTE (LAMBDA (Y) (CONS X Y)))
                 (QUOTE (P Q R)))))
 (X . (A B C)))
----

Inner `MAPCAR` gets `(LAMBDA (Y) (CONS X Y))` and `(P Q R)` as two
actual parameters, which are bound to `MAPCAR`{nbsp}'s formal paramter
`FN` and `X` again, and the environment under which innter `MAPCAR`{nbsp}'s
body is evaluated looks like this:

----
((FN . (LAMBDA (Y) (CONS X Y)))
 (X . (P Q R))
 (X . A)
 (FN . (LAMBDA (X)
         (MAPCAR (QUOTE (LAMBDA (Y) (CONS X Y)))
                 (QUOTE (P Q R)))))
 (X . (A B C)))
----

Finally, innter `LAMBDA` is called -- first, `P` as the
actual parameter, which is bound to `Y`.  Hence the body
of the inner `LAMBDA`, which is `(CONS X Y)`, is evaluated
under the following environment:

----
((Y . P)
 (FN . (LAMBDA (Y) (CONS X Y)))
 (X . (P Q R))                                <1>
 (X . A)                                      <2> 
 (FN . (LAMBDA (X)
         (MAPCAR (QUOTE (LAMBDA (Y) (CONS X Y)))
                 (QUOTE (P Q R)))))
 (X . (A B C)))                               <3>
----

1. Argument for the inner `MAPCAR`
2. Argument for the outer `LAMBDA`
3. Argument for the outer `MAPCAR`

Now it is clear why it didn't work.   When we write the
initial nested `MAPCAR` form, we expect that `X` in the
innermost expression `(CONS X Y)` refer to the formal parameter of the
outer `LAMBDA`.  But it is shadowed by the formal parameter of the
`MAPCAR`.

This is a well-known problem, and in lambda calculus it is avoided
by _renaming_ the parameter names to avoid conflict.  In our case,
if we rename the formal parameter of inner `LAMBDA` to something
different from the formal parameter of `MAPCAR`, it works as expected:

----
(EVAL* '(MAPCAR (QUOTE (LAMBDA (Z)                                  <1>
                         (MAPCAR (QUOTE (LAMBDA (Y) (CONS Z Y))) 
                                 (QUOTE (P Q R)))))
                (QUOTE (A B C))))
 => (((A . P) (A . Q) (A . R)) ((B . P) (B . Q) (B . R)) ((C . P) (C . Q) (C . R)))
----

1. We use `Z` to avoid confclit with `MAPCAR`{nbsp}'s `X`.

However, we can't possibly avoid all potential conflict manually,
and renaming all formal parameters programatically to unique ones can be costly.

LISP1.5 employed another way to solve this problem.  Instead of passing
`LAMBDA` form quoted, it introduced another form, called `FUNCTION`.
The rule is that whenever you pass a function as an argument,
you wrap it with `FUNCTION` instead of `QUOTE`.  With this rule,
our call of nested `MAPCAR` would look like this:

----
(EVAL* '(MAPCAR (FUNCTION (LAMBDA (X)
                            (MAPCAR (FUNCTION (LAMBDA (Y) (CONS X Y))) 
                                    (QUOTE (P Q R)))))
                (QUOTE (A B C))))
----

Now we modify our universal LISP function to deal with `FUNCTION`.
We only need to change two lines.  First, make `EVAL` understand
`(FUNCTION <fn>)` form.  Whenver it sees the form, it just
returns a list `(FUNARG <fn> <env>)`, where `<env>` is the evaluation
enviornment:

----
eval[e;a] =
  [atom[e] -> cdr[assoc[e;a]];
   atom[car[e]] -> [eq[car[e];QUOTE] -> cadr[e];
                    eq[car[e];FUNCTION] -> cons[FUNARG;cons[cadr[e];cons[a;NIL]]]; <1>
                    eq[car[e];COND] -> evcon[cdr[e];a];
                    T -> apply[car[e];evlis[cdr[e];a];a]];
   T -> apply[car[e];evlis[cdr[e];a];a]]
----

1. If we see `(FUNCTION <fn>)` form, wrap the function and the current environment in `FUNARG` form, as `(FUNARG <fn> <env>)`.


Then, in `APPLY`, we call `<fn>` with the rememberd `<env>` instead of
the passed environment:

----
apply[fn;x;a] =
  [atom[fn] -> [eq[fn;CAR] -> caar[x];
                eq[fn;CDR] -> cdar[x];
                eq[fn;CONS] -> cons[car[x];cadr[x]];
                eq[fn;ATOM] -> atom[car[x]];
                eq[fn;EQ] -> eq[car[x];cadr[x]];
                T -> apply[eval[fn;a];x;a]];
   eq[car[fn];FUNARG] -> apply[cadr[fn];x;caddr[fn]];                  <1>
   eq[car[fn];LAMBDA] -> eval[caddr[fn];pairlis[cadr[fn];x;a]];
   eq[car[fn];LABEL] -> apply[caddr[fn];x;cons[cons[cadr[fn];caddr[fn]];a]]]
----

1. Apply the wrapped function in the rememberd environment


The changed definitions are in link:mx/funarg.mx[].  You can load it
and see it addresses the issue (which has been called FUNARG problem).

----
$ gosh -I. -u LISP1.5.axioms -l mx/funarg.mx
gosh> ,l lisp/mapcar.lisp
#t
gosh> (EVAL* '(MAPCAR (FUNCTION (LAMBDA (X)
                         (MAPCAR (FUNCTION (LAMBDA (Y) (CONS X Y)))
                                 (QUOTE (P Q R)))))
                (QUOTE (A B C))))
(((A . P) (A . Q) (A . R)) ((B . P) (B . Q) (B . R)) ((C . P) (C . Q) (C . R)))
----

[NOTE]
==========================================================
Did you notice that you actually did't need `FUNCTION`?  Instead
of introducing another form, you can let `EVAL` create `FUNARG`
when it sees a bare `LAMBDA` form.  The definition will look like this:

----
eval[e;a] =
  [atom[e] -> cdr[assoc[e;a]];
   atom[car[e]] -> [eq[car[e];QUOTE] -> cadr[e];
                    eq[car[e];LAMBDA] -> cons[FUNARG;cons[e;cons[a;NIL]]];
                    eq[car[e];COND] -> evcon[cdr[e];a];
                    T -> apply[car[e];evlis[cdr[e];a];a]];
   T -> apply[car[e];evlis[cdr[e];a];a]]
----

The updated definition is in link:mx/funarg-lambda.mx[].  Using it,
calling `MAPCAR` becomes quite simpler:

----
$ gosh -I. -u LISP1.5.axioms -l mx/funarg-lambda.mx
gosh> ,l lisp/mapcar.lisp
#t
gosh> (EVAL* '(MAPCAR (LAMBDA (X)
                        (MAPCAR (LAMBDA (Y) (CONS X Y))
                                (QUOTE (P Q R))))
                      (QUOTE (A B C))))
(((A . P) (A . Q) (A . R)) ((B . P) (B . Q) (B . R)) ((C . P) (C . Q) (C . R)))
----

This idea was realized by Sussman and Steele in 1975, as a dialect
Scheme.  The first paper of Scheme stated it at the beginning:

[quote, Gerald Jay Sussman and Guy Lewis Steele Jr., 'SCHEME: An Interpreter For Extended Lambda Calculus']
----
SCHEME is essentially a full-funarg LISP.  LAMBDA expressions need
not be QUOTEd, FUNCTIONed, or *FUNCTIONed when passed as arguments or
returned as values; they will evaluate to closures themselves.
----

==========================================================


=== Symbols and toplevel environment

So far, our `EVAL` requires any bindings to be provided
via the environment argument.  Preprocessing the source with `mexpr-env.scm`
was a remedy, but it's still troublesome.  So our next step is to
add a toplevel environment, that keeps global bindings of `DEFINE`{}d
symbols.

The easiest way is to keep a global table, and when we search
a variable binding via `ASSOC` (in the first branch of `EVAL`),
we also look up the table when we didn't find any local bindings.

However, LISP1.5 took a bit different approach. Since its symbol had
a property list, or _plist_, which could hold arbitrary key-value
pairs, so I suspect it was natural to store the global value
of the symbol in its plist.  In fact, even the name of a symbol
was merely one of its properties.  In LISP1.5, a symbol was just
another type of list where the car of its head was marked
with a special value (-1).

[NOTE]
====
A property list (plist) associates keys to values, much like
an associative list (alist),
but its structure alternates keys and values.  For example, if
key `A` has value `APPLE` and key `B` has a value `BANANA`, it can
be represented with the following alist and plist, respectively:

----
;; alist
((A . APPLE) (B . BANANA))

;; plist
(A APPLE B BANANA)
----

The number of cons cells used are the same.  We're not sure why LISP1.5
creators used plist for symbol properties, while they used
alist for environment in `EVAL`.
====

In our minimal infrastructure (link:LISP1/5/axioms.scm[]) we just
used Gauche symbols for LISP symbols.  It might be interesting,
though, to reproduce what LISP1.5 did -- using a list to implement
symbols!

That is, from now on, our LISP symbol is a pair whose car is
a special marker.  We use Gauche symbol `ATOM`.  From LISP world,
a LISP symbol is an unbreakable unit (hence it is called _atom_), so
the marker is never be visible.  Under the hood, in Gauche level,
we can break an atom to access its internal structure.  It is as
if LISP world deals with chemical reactions and Gauche world deals
with nuclear reactions.

In LISP symbols, its name is stored as a value of the property
`PNAME`.  Since the property list is scanned by LISP function,
we have to use LISP symbols as the property key.  For the name itself,
we use a Scheme string; in real LISP1.5, the name is stored
in a special way and treated specially (there wasn't a string type).

Thus, LISP symbol `PNAME` has the following structure in Gauche:

[source, scheme]
----
(define *PNAME* '#0=(ATOM #0# "PNAME"))
----

The `#0=` notation is a Scheme way to write a circular structure.
The symbol `PNAME` has a propoerty list, in which the key `PNAME`
is associated to the name `"PNAME"`.   Note that they LISP symbol
`PNAME` itself doesn't have a global value.

The global value of symbols is stored as a propery value with
the key `APVAL`.  So we need the LISP symbol `APVAL`, which looks
like the following in Gauche.  `APVAL` itself doesn't have a global
value either:

[source, scheme]
----
(define *APVAL* `(ATOM ,*PNAME* "APVAL"))
----

Once we have `PNAME` and `APVAL`, we can define `NIL`, whose name
is `"NIL"` and value is itself.  We can't use `#0=` notation this time,
since we have to construct the list using values of `\*PNAME\*` etc.

[source, scheme]
----
(define *NIL* (rlet1 nil (list 'ATOM *PNAME* "NIL" *APVAL*)
                (set! (cddddr nil) (list nil))))
----

Here's how `\*NIL\*` looks like in Gauche world.
`#1=(ATOM #1# "PNAME")` is LISP symbol `PNAME`, and
`(ATOM #1# "APVAL")` is LISP symbol `APVAL`.  Remember we're looking
at the internal of atoms -- from LISP world, this is just a symbol
`NIL`.

----
gosh> *NIL*
#0=(ATOM #1=(ATOM #1# "PNAME") "NIL" (ATOM #1# "APVAL") #0#)
----

We can define several symbols in this way.  See link:LISP1/5/runtime.scm[]
for all the predefined symbols.

Let's start building infrastructure.  Our LISP world only have symbols
and cons cells so far (we'll add numbers later).  We can define `$atom?`
and `$cons?` as follows (The `$` indicates it deals with LISP objects):

[source, scheme]
----
(define ($atom? obj) (and (pair? obj) (eq? (car obj) 'ATOM)))
(define ($cons? obj) (and (pair? obj) (not (eq? (car obj) 'ATOM))))
----

Then we can define `$lisp\->scheme`, which converts LISP data structure
into Scheme data structure, handy for debugging.
We map `NIL` inside the structure into Scheme empty list, so that
list structure can be printed naturally (instead of having `. NIL)`
at the end.)

[source, scheme]
----
(define ($lisp->scheme obj)
  (define (rec obj)
    (cond [(eq? obj *NIL*) '()]
          [($atom? obj) (string->symbol (cadr (member *PNAME* (cdr obj))))]
          [else (cons (rec (car obj)) (rec (cdr obj)))]))
  (if (eq? obj *NIL*)
    'NIL
    (rec obj)))
----

It's also handy to have `$scheme\->lisp`, which converts Scheme
structure into LISP structure.   One important point: We want to keep
symbol's `eq`{nbsp}-ness, that is, LISP symbols with the same name
can be compared with `eq`.  So we keep a hashtable to map Scheme
symbol to LISP symbols.

[source, scheme]
----
(define *obtable* (hash-table-r7 eq-comparator
                                 'NIL *NIL*
                                 'PNAME *PNAME*
                                 'APVAL *APVAL*))

(define ($scheme->lisp obj)
  (cond [(null? obj) *NIL*]
        [(symbol? obj) (or (hash-table-get *obtable* obj #f)
                           (rlet1 s (list 'ATOM *PNAME* (symbol->string obj))
                             (hash-table-put! *obtable* obj s)))]
        [(pair? obj) (cons ($scheme->lisp (car obj))
                           ($scheme->lisp (cdr obj)))]
        [else (errorf "Cannot convert ~s to LISP" obj)]))
----

Let's try them.  Converting Scheme `(A B C D E)` into LISP results
somewhat scary structure, but converting it back shows it's nothing
to be afraid of:

----
gosh> ($scheme->lisp '(A B C D E))
((ATOM #0=(ATOM #0# "PNAME") "A") (ATOM #0# "B") (ATOM #0# "C")
 (ATOM #0# "D") (ATOM #0# "E") . #1=(ATOM #0# "NIL" (ATOM #0# "APVAL") #1#))
gosh> ($lisp->scheme *1)
(A B C D E)
----





== Building Runtime

In the previous section we showed we can run a complete LISP interpreter
on top of a handful of primitive operators.
Providing those operators are link:LISP1/5/axioms.scm[incredibly easy] -- only
a half page of code can bootstrap Lisp!

Well, there's an important omission.  To provide `CONS`, for example,
you have to allocate a piece of memory somewhere.  
To read and write M- or S-expressions,
you need I/O.  In link:LISP1/5/axioms.scm[], we just put those work
on Gauche runtime.  Isn't it a kind of cheat?  Don't you want to
know what it _really_ takes to build a LISP system from scratch?

Well then, let's do that!

=== Memory model

We start from the memory.

IBM704, on which LISP was first developed, was a 36-bit machine.
Its memory was basically an array of 36-bit words -- each address
can hold a word, not an 8-bit byte.
Each word can be broken up to 4 parts:
3-bit _prefix_, 15-bit _decrement_, 3-bit _tag_, and 15-bit _address_.
The memory can be fully accessed with 15-bit address, so each word
can have two pointers.
`CAR` and `CDR` came from _contends of address part of register_ and
_contents of decrement part of register_.
I suspect that this architecture of IBM704
influenced the design of LISP using two-pointer cells (_cons cells_)
for almost everything.

To store characters, a word is viewed as a chunk of six 6-bit
characters.  In LISP1.5, such words that are not used as two-pointer
cells are called _full word_.  A character string is represented
as a list of such full words.  (Though LISP1.5 didn't have a string
object -- list of full words only appears as an attribute value
of atomic symbols).

Distinguishing cons cells and full words are done by simply
splitting memory into regions; certain region only stores cons cells,
and another region only sotres full words.  So you can tell which is which
by looking at the address.

We don't really write an emulator of IBM704, but we can taste
its flavor by defining our memory as an array of words.

Let's use `u32vector` as our memory.  Our word is 32bit.  For a cell,
we read it as two 16bit addresses; so we have 65536 words.  So small, yeh?
It still amounts 256KB of memory and that was luxury back then.

To keep things simple, we split our 16bit address space into two even
spaces; first half for the cells, and second half for the full words.
Then we can look at the MSB of the address to say which is which.

----
                 32bit word
       +----------------------------+
#xffff |                            |
       |                            |
       |         Full words         |
       |                            |
#x8000 |                            |
       +----------------------------+
#x7fff |                            |
       |                            |
       |         Cons cells         |
       |                            |
#x0000 |                            |
       +----------------------------+
----       

A cons cell consists of two 16-bit addresses:

----
                      16bits         16bits
                 +--------------+--------------+
      Cons cell: |     CDR      |     CAR      |
                 +--------------+--------------+
----

A full word may be used for character strings, numbers (32bit signed
fixnum or 32bit single-precision floating number),
and native objects.

Character strings are a list of cells each of whose CDR points to a
full word, which can contain up to 8 octets, NUL-padded.  Character
strings are not first-class object in LISP1.5 and can only appear
as the name of symbols.

A native object is a backdoor for LISP1.5 programs to access
underlying Gauche features; certain primitive functions are
implemented in Gauche level, and called from LISP1.5 via native
objects.  It is simply a index to a native object vector.

Numbers and native objects are always pointed from CDR of a special cons
cell, whose CAR has a special value to distinguish itself from the ordinary
cons cells.  We use the following special values to _tag_ the special
cons cells.

* #xffff - The cell is a symbol, and its CDR has a property list.
* #xfffe - The cell is a native object, and its CDR is an index to
the native object vector.
* #xfffd - The cell is a fixnum, and its CDR points to a full word of
32bit signed integer.
* #xfffc - The cell is a flonum, and its CDR points to a full word of
32bit floating point number.

We reserve full words at these addresses, so that no valid pointer
can use these values.

[NOTE]
==================================================================
In original LISP1.5, an atom is a cell with -1 (#o77777) in its CAR.
An atom can be a symbol or a number.  The type of the atom is
distinguished by the tag field of the word.
==================================================================

=== Symbols




=== Allocator and garbage collector

We have `CONS` to allocate memory, but there's no operation to explicitly
free it.  Instead, we scan the memory and reclaim unused words when
needed.  LISP was the birthplace of garbage collection.

LISP1.5 used mark-and-sweep garbage collector.   For cons cells,
sign bit (in the prefix field) is used as a mark bit, and for full words,
separate bittable is used as mark bits.

In our architecture we don't have any extra bit, but we can
put extra piece of memory.  So, let's assume we have a special
kind of memory outside of the address space, where each bit
corresponds to each word in the main memory.  We'll provide
primitives to read and modify those bits.

Memory allocation works as follows:

* Initially, all the available cons cells and available full words
are chained to each _freelist_.  Each entry of the free list looks like
this (0 in the next word indicates the end of the list).

----
                      16bits         16bits
                 +--------------+--------------+
Free list entry: |      0       |  next word   |
                 +--------------+--------------+
----

* Every time we need a new cons cell or full word, we take one from
either freelist.  If we exhaust either one, we trigger GC.

Our garbage collector is a traditional mark-and-sweep GC:

* Clear the mark bits.
* From the root set, we trace all the pointers and mark the visited words.
* Scan the mark bits and push words that hasn't been marked to the freelist.

However, there's a catch -- our collector itself is written in LISP,
so it needs to allocate some memory

=== Standard library

=== Applications


