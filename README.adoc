// -*- coding: utf-8 -*-
= LISP1.5 implementation on Gauche

This is a fun project to implement LISP 1.5 as described in
``LISP 1.5 Programmer's Manual''.  It's not a complete LISP 1.5 environment
emulator; instead, it is to get a glimpse of how it is constructed.

It comes with a few components.

== M-expression

Back then, M-expression was for human to write and read programs on paper,
but you had to manually translate it to S-expression then punch the cards.
Now you can make the computer understand M-expression directly!

An example can be found in link:examples/eval.mx[].

=== M-expression syntax summary

- Identifiers are in all lowercase.  Literal symbols are in all uppercase.
  No `quote` in M-expression.  Literal list can be written using parentheses,
  e.g. `(A B (C D . E))`, without a quote.
- Function call is written as `fn[arg1;arg2;...]`
- Conditional is `[test1 \-> expr1; test2 \-> expr2;...]`.  It works just like
  `cond`.   Unicode arrow character `->` (U+2192) can be used in place of `\->`.
- Symbol `NIL` is used for list terminator.  Hence `cons[A;NIL]` yields
  `(A)`.
- Literal function is written as `lambda[[arg;..];expr]`.
- Local recursive function can be written as `label[name;expr]`, where
  you can use `name` in the `expr` to refer to itself.
- In toplevel, you can define a function by `name[arg;...] = expr`.

We also add this extension:

- A hash sign `#` to the end of line is a comment.  We avoid `;`, for
  it is used as a separator.

=== Calling M-expression parser

Module `LISP1.5.mexpr` implements parsers.  A procedure
`parse-mexpr` takes a string or an input port, and parses one M-expression
and returns an S-expression.

[source,console]
----
gosh> ,u LISP1.5.mexpr
gosh> (parse-mexpr "cons[(A . B);C]")
(CONS (QUOTE (A . B)) (QUOTE C))
----

Note that uppercase names and lists in M-expression are literals,
hence QUOTEd once parsed.

If the input can contain more than one M-expression, use `parse-mexprs`
instead, which reads input up to EOF and returns an lseq of result
S-expressions.

If, for whaterver reason, you want to embed M-expression inside Scheme,
use `LISP1.5.mexpr-reader` module.  It defines srfi-10 reader constructor
`m-expr`, which takes M-expression in string:

[source,console]
----
gosh> ,u LISP1.5.mexpr-reader
gosh> '#,(m-expr "cons[X;Y]")
(CONS (QUOTE X) (QUOTE Y))
----

(The `#,(m-expr "cons[X;Y]")` form is replaced to `(CONS (QUOTE X) (QUOTE Y))`
by the reader.  Without the quote before it, REPL tries to evaluate
the resulting S-expression, which would yield an error because
Gauche doesn't know `CONS`, `QUOTE` etc.  Those primitives
are defined in `LISP1.5.interp` module.  Read on.)


=== Writing source in M-expression:

You can write M-expression in Scheme source code using `#!m-expr` directive.
You have to `use` one of LISP1.5 modules that provides the feature.

[source,console]
----
;;
;; Scheme comments
;; 
(use LISP1.5.interp)
#!m-expr

# M-expression source ...
----




== Miminal interpreter and a universal LISP function

link:examples/eval.mx[] is the source of LISP `eval` described in the
section 1.6 of the manual.  You can load it directly into `gosh`:

[source,console]
----
$ gosh -I. -l examples/eval.mx
----

or

[source,console]
----
gosh> ,l examples/eval.mx
----

Be aware that loading it overrides `car`, `cdr`, `caar`,
`cadr`, `cdar`, `caddr`, `cadar`, `cons`, `append`, `member`, `assoc`,
`eval`, `apply` and `cond`.  

You can run

[source,console]
----
gosh> (eval '(CAR (CONS (CDR (QUOTE (A . B))) (QUOTE C))) 'NIL)
B
----
