// -*- coding: utf-8 -*-
= LISP1.5 implementation on Gauche
:sectnums:
:toc:
:toc-placement!:
ifdef::env-github[]
:tip-caption: :bulb:
endif::[]

This is a fun project to implement LISP 1.5 as described in
"LISP 1.5 Programmer's Manual".  It's not a complete LISP 1.5 environment
emulator; instead, it is to get a glimpse of how it is constructed.

toc::[]


== M-expressions

Back then, M-expression was for human to write and read programs on paper,
but you had to manually translate it to S-expression then punch the cards.
Now you can make the computer understand M-expression directly!

=== M-expression syntax summary

- Identifiers are in all lowercase.  Literal symbols are in all uppercase.
  No `quote` in M-expression.  Literal list can be written using parentheses,
  e.g. `(A B (C D . E))`, without a quote.
- Function call is written as `fn[arg1;arg2;...]`
- Conditional is `[test1 \-> expr1; test2 \-> expr2;...]`.  It works just like
  `cond`.   Unicode arrow character `->` (U+2192) can be used in place of `\->`.
- Symbol `NIL` is used for list terminator.  Hence `cons[A;NIL]` yields
  `(A)`.
- Literal function is written as `lambda[[arg;..];expr]`.  This lambda form
itself doesn't have a value -- it must be called with arguments to take effect.
- Local recursive function can be written as `label[name;lambda[[arg;...];expr]]`,
where you can use `name` in the `expr` to refer to itself.
- In toplevel, you can define a function by `name[arg;...] = expr`.

We also add this extension:

- A hash sign `#` to the end of line is a comment.  We avoid `;`, for
  it is used as a separator.


=== Calling M-expression parser

Module `LISP1.5.mexpr` implements parsers.  A procedure
`parse-mexpr` takes a string or an input port, and parses one M-expression
and returns an S-expression.

----
gosh> ,u LISP1.5.mexpr
gosh> (parse-mexpr "cons[(A . B);C]")
(CONS (QUOTE (A . B)) (QUOTE C))
----

Uppercase names and lists in M-expression are literals,
hence they are `QUOTE`-{nbsp}d once parsed.

If the input may contain more than one M-expression, use `parse-mexprs`
instead, which reads input up to EOF and returns an lseq of result
S-expressions.


=== Writing source in M-expression:

You can write M-expression in Scheme source code using `#!m-expr` directive.

----
;;
;; Scheme comments
;; 
(use LISP1.5.mexpr)
#!m-expr

# M-expression function definitions
function1[arg;...] = expression1
function2[arg;...] = expression2
...
----

The `#!m-expr` directive translates those M-expressions into
a LISP1.5 `DEFINE` form:

----
(DEFINE
 ((FUNCTION1 (LAMBDA (ARG ...) EXPRESSION1))
  (FUNCTION2 (LAMBDA (ARG ...) EXPRESSION2))
  ...))
----

Note that you have to have definitions of `DEFINE` and other primitive
LISP1.5 forms before loading the source file; The `LISP1.5.mexpr` module
only handles parsing.

We provide several implementations of those LISP1.5 primitives,
which we'll show you in the following chapters.


== A Universal LISP Function

=== Running EVAL with minimal axioms

Section 1.6 of "LISP 1.5 Programmier's Manual" is one of the pinnacles
of the document.  They show how to implement Lisp interpreter
on top of Lisp systems.  They call it a "Universal LISP function".

We write out their code in link:examples/eval.mx[].

What's interesting about it is that you only need a handful of
functions and syntaxes to run the interpreter.  We define those
minimal set of primitives in link:LISP1/5/axioms.scm[].
It provides the definition of the following primitives:
`CAR`, `CDR`, `CONS`, `ATOM`, `EQ`, `QUOTE`, `COND`, and `DEFINE`.

To try the eval function, first `use` the axioms module, then
load the `eval.mx` file.  Assuming you have
load path set to the top directory of LISP1.5 source,
you can say the following in the gosh REPL:

----
gosh> ,u LISP1.5.axioms
gosh> ,l examples/eval.mx
#t
----

Or, you can start gosh with loading necessary modules
(this assumes you're in the top directory of LISP1.5 source):

----
$ gosh -I. -u LISP1.5.axioms -l examples/eval.mx
----

On the gosh prompt, you can call `EVAL`.  The first argument
is the S-expression to evaluate, and the second argument
is the environment (assoc list of symbols and values):

----
gosh> (EVAL '(CONS (CAR (QUOTE (X . Y))) (QUOTE Z)) 'NIL)
(X . Z)
----

Be aware of the difference of `'` (`quote`) and `QUOTE`.
The former one is recognized by Gauche.  The latter one is recognized by
`EVAL`.

If you prefer, you can write M-expressions using
read-time constructor `#,(m-expr "...")`:

----
gosh> (EVAL '#,(m-expr "cons[car[(X . Y)];Z]") 'NIL)
(X . Z)
----

Following is a bit more convoluted example.  It defines `append`
as a recursive funciton using `LABEL`, and calls it with
two arguments, `(A B C)` and `(X Y Z)`:


----
gosh> (EVAL '#,(m-expr "label[append;lambda[[xs;r];\
                               [eq[xs;NIL] -> r;\
                                T -> cons[car[xs];append[cdr[xs];r]]]]]\
                        [(A B C);(X Y Z)]")
            'NIL)
(A B C X Y Z)
----

This interpreter only _knows_ the minimal 7 primitives:
`CAR`, `CDR`, `CONS`, `ATOM`, `EQ`, `QUOTE`, and `COND`.
To refer to anything other than that, 
you have to pass them as the environment argument.

The following example reverses a list, using the
definition of `NULL`, `APPEND` and `REVERSE` given to the environment:

----
gosh> (EVAL '#,(m-expr "reverse[(A B C D E F G)]")
            '((NULL . #,(m-expr "lambda[[x];[eq[x;NIL] -> T; T -> F]]"))
              (APPEND . #,(m-expr "lambda[[xs;r];\
                                     [eq[xs;NIL] -> r;\
                                      T -> cons[car[xs];append[cdr[xs];r]]]]"))
              (REVERSE . #,(m-expr "lambda[[xs];\
                                      [null[xs] -> NIL;\
                                       T -> append[reverse[cdr[xs]];cons[car[xs];NIL]]]]"))
             ))
(G F D C B A)
----

We need to have the function `NULL` in the environment, 
since the one defined in `eval.mx` exists in the world of Gauche, and
not visible from the world of `EVAL`.

[TIP]
.If you use undefined variable...
********************************************************************
When you refer to an identifier that's neither one of the built-in
primitive nor the one given in the environment, you'll get an error
like the following:

----
*** ERROR: pair required, but got NIL
Stack Trace:
_______________________________________
  0  (car x)
        at "./LISP1/5/axioms.scm":9
  1  (CAR X)
        [unknown location]
  2  (CAAR A)
        [unknown location]
  3  (EQUAL (CAAR A) X)
        [unknown location]
  4  (ASSOC E A)
        [unknown location]
  5  (EVAL FN A)
        [unknown location]
...
----

The code searches the environment alist by `ASSOC`, hits the end of
the alist without finding it and complains.  Remember, we have minimal
interpreter and there's no fancy error handling mechanism.
********************************************************************


=== Going Metacircular

Since the universal LISP function defined in `eval.mx` understands
the primitives required to interpret functions in `eval.mx`, you can use
our `EVAL` to evaluate `eval.mx` to run `EVAL` on top of 
`EVAL` -- now you're running a metacircular interpreter!

You might have noticed though, that `axioms.scm` provides `DEFINE`,
which is missing in `eval.mx`.  In our context of discussing
metacircular interpreter, `DEFINE` appears as a result of
parsing M-expression definitions, and should be understood
as a meta-language to direct the set-up, rather than an integrated
part of the language (one way to think of it is that if other primitives
are C built-ins then `DEFINE` is `#pragma` or `Makefile` -- they belong
to a slightly different layer.)

Of course, it is more convenient to include `DEFINE` in the core language,
and we'll deal with it later.  For now, let's stick to the primitives
excluding `DEFINE`.

In order to run `EVAL` inside `EVAL`, we need to prepare the definitions
in `eval.mx` as an environment alist passed to outer `EVAL`.
Run the following command in the toplevel source directory:

----
$ gosh tools/mexpr-env.scm examples/eval.mx
----

It reads `eval.mx` and prints the definitions in an alist.  Copy the output,
then start `gosh` again, read `axioms` and load `eval.mx`, and evaluate
the `EVAL` expression, passing the copied alist as the environment
(don't forget the quote before the alist!):


----
gosh> ,u LISP1.5.axioms
gosh> ,l examples/eval.mx
#t
gosh> (EVAL '(EVAL (QUOTE (CAR (QUOTE (X . Y)))) (QUOTE NIL))
            '...<<here, copy & paste the output of mexpr-env.scm>>)
X
----

The result `X` is the result of `(CAR (QUOTE (X . Y)))`, computed
by the `EVAL` function implemented in LISP1.5, not the underlying Gauche.

If cut&pasting the environment alist is too tedious, `mexpr-env.scm` can
create a definition of an auxiliary function `EVAL*`, which calls `EVAL`
with the environment that has all the definitions in the given source file.
Run `mexpr-env.scm` with `-e` option, and save the result in `lisp/eval.lisp`:

----
$ gosh tools/mexpr-env.scm -e examples/eval.mx > lisp/eval.lisp
----

[TIP]
********************************************************************
Instead of manually executing `tools/mexpr-env.scm`, you can
run the standard build process (`./configur && make`) and
all the converted files are placed under `lisp/`.
********************************************************************

We use suffix `lisp` to indicate it is not a Scheme code (even though
Gauche can understand it after using `LISP1.5.axioms`).
The created `lisp/eval.lisp` looks as follows:

----
(DEFINE ((EVAL* (LAMBDA (X) (EVAL X '...<<environment defined in eval.mx>>...
)))))
----

That is, it defines `EVAL*` which takes one LISP1.5 expression and
evaluates it under the enviornment where all the definitions in `eval.mx`
is visible.

The created `eval.lisp` can be loaded to `gosh` after using `LISP1.5.axioms`.  
Together with `examples/eval.mx`, you can run `EVAL` on top of `EVAL`:

----
$ gosh -I. -uLISP1.5.axioms -lexamples/eval.mx -leval-star.lisp
gosh> (EVAL* '#,(m-expr"eval[(CONS (QUOTE X) (QUOTE Y));NIL]"))
(X . Y)
----

This time we used M-expression in the inner call.  It's the same
as writing `'(EVAL (QUOTE (CONS (QUOTE X) (QUOTE Y))) (QUOTE NIL))`.

Let's recap what's happening.  The outer `EVAL` (via `EVAL*`) is
executed by Gauche, using the initially loaded `eval.mx`.  The
inner `EVAL` is interpreted by the outer `EVAL`, using the
enviornment created by `mexpr-env.scm`.
And the expression `(CONS (QUOTE X) (QUOTE Y))` is interpreted by
the inner `EVAL`:

----
        +----------------------------+
        | (CONS (QUOTE X) (QUOTE Y)) |
        +----------------------------+
        |           EVAL             |  ; inner EVAL
        +----------------------------+
        |           EVAL             |  ; outer EVAL
        +----------------------------+
        |          Gauche            |
        +----------------------------+
----

If it is not obvious, try it with alternated environment.
For example, edit the `eval.lisp` created above
to change the inner `EVAL` recognizes `KWOTE` instead of `QUOTE`.
There's only one place to change:

----
 (EVAL
  LAMBDA
  (E A)
  (COND
   ((ATOM E) (CDR (ASSOC E A)))
   ((ATOM (CAR E))
    (COND ((EQ (CAR E) (QUOTE KWOTE)) (CADR E))
                              ^^^^^
     ((EQ (CAR E) (QUOTE COND)) (EVCON (CDR E) A))
     ((QUOTE T) (APPLY (CAR E) (EVLIS (CDR E) A) A))))
   ((QUOTE T) (APPLY (CAR E) (EVLIS (CDR E) A) A))))
----

(Leave other `QUOTE` intact, for they are recognized by the outer `EVAL`).

Now, try it:

----
(EVAL* '(EVAL (QUOTE (CONS (KWOTE X) (KWOTE Y))) (QUOTE NIL)))
  => (X . Y)
----

The two `QUOTE`{nbsp}'s are recognized by the outer `EVAL`, and the two
`KWOTE`{nbsp}'s are recognized by the inner `EVAL`.  Furthermore,
the `'` (`quote`) is recognized by Gauche.


=== Having FUN with ARG

One advantage of having a simple language with a concise interpreter is
that we can tweak it easily.

In the universal `EVAL`, a function is represented as a literal list
whose car is `LAMBDA`.  It is a powerful idea--now you can have
a function as a first-class citizen of the language, that you can
construct it, pass it to another function, and return it from another
funciton.  However, it has a flaw.

Let's check the flaw and see if we can fix it.

Consider `MAPCAR` function, which takes a function and a list, and
returns a list of results of the function applied to each element of the
given list (that is, Scheme's `map` function):

----
mapcar[f;x] = [null[x] -> NIL;
               T -> cons[f[car[x]];mapcar[f;cdr[x]]]]
----

It is in link:examples/mapcar.mx[].  You can't load it directly
into Gauche, however.  Treating a list starting with `LAMBDA` as
a function is a feature of `EVAL`, not Gauche.  
We have to make `EVAL` understand the above definition.

We can use the same technique we used in the metacircular interpreter --
that is, translate the definition of `MAPCAR` above into an enviroment
alist.  We also need the definition of `NULL`, so let's combine
`eval.mx` together with `mapcar.mx`.  It can be done with the following
command line:

----
$ gosh tools/mexpr-env.scm -e examples/eval.mx examples/mapcar.mx > lisp/mapcar.lisp
----

Alternatively, run `./configure` then `make` in the toplevel source directory.

Once you have `lisp/mapcar.lisp`, you can load it (after `examples/eval.mx`)
and you can call `MAPCAR` inside `EVAL*`:

----
$ gosh -I. -uLISP1.5.axioms
gosh> ,l examples/eval.mx
#t
gosh> ,l lisp/mapcar.lisp
#t
gosh> (EVAL* '(MAPCAR (QUOTE (LAMBDA (X) (CONS X (QUOTE Y)))) (QUOTE (A B C))))
((A . Y) (B . Y) (C . Y))
gosh> (EVAL* '#,(m-expr "mapcar[(LAMBDA (X) (CONS X (QUOTE Y)));(A B C)]"))
((A . Y) (B . Y) (C . Y))
----

So far, so good.

Now, Let's try nesting `MAPCAR`.  We'll do equivalent to the following
Scheme code:

----
(map (lambda (x) (map (lambda (y) (cons x y)) '(p q r))) '(a b c))
  => (((a . p) (a . q) (a . r)) ((b . p) (b . q) (b . r)) ((c . p) (c . q) (c . r)))
----

Here's LISP1.5 version:

----
(EVAL* '(MAPCAR (QUOTE (LAMBDA (X)
                         (MAPCAR (QUOTE (LAMBDA (Y) (CONS X Y)))
                                 (QUOTE (P Q R)))))
                (QUOTE (A B C))))
  => ((((P Q R) . P) ((Q R) . Q) ((R) . R)) (((P Q R) . P) ((Q R) . Q) ((R) . R)) (((P Q R) . P) ((Q R) . Q) ((R) . R)))
----

Oops, what happened?  Let's look at the evaluation of the above `MAPCAR`
step by step.  First, `EVAL*` calls `EVAL` with a bunch of definitions.
Here, `e` is our outer `(MAPCAR ...)` expression, and `a` is the environment:

----
eval[e;a] =
  [atom[e] -> cdr[assoc[e;a]];
   atom[car[e]] -> [eq[car[e];QUOTE] -> cadr[e];
                    eq[car[e];COND] -> evcon[cdr[e];a];
                    T -> apply[car[e];evlis[cdr[e];a];a]];  <1>
   T -> apply[car[e];evlis[cdr[e];a];a]]
----

<1> This branch is executed.






----
(EVAL* '(MAPCAR (QUOTE (LAMBDA (Q)
                         (MAPCAR (QUOTE (LAMBDA (Y) (CONS Q Y))) 
                                 (QUOTE (A B C)))))
                (QUOTE (X Y Z))))
(((X . A) (X . B) (X . C)) ((Y . A) (Y . B) (Y . C)) ((Z . A) (Z . B) (Z . C)))
----
