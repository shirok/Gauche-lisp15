// -*- coding: utf-8 -*-
= LISP1.5 implementation on Gauche
:sectnums:
:toc:
:toc-placement!:
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

This is a fun project to implement LISP 1.5 as described in
"LISP 1.5 Programmer's Manual".  It's not a complete LISP 1.5 environment
emulator; instead, it is to get a glimpse of how it is constructed.

toc::[]


== M-expressions

When LISP was in its infancy, it wasn't wrapped with so many parentheses
which would later become its most memorable characteristic.
At least in front of people's eyes.

An early LISP program looked like this:

----
member[a;l] = [null[l] → NIL;
               eq[a;car[l]] → l;
               T → member[a;cdr[l]]]
----

S-expressions are used to denote _data_, which was
basically nested list structures.

----
member[C;(A B C D E)] => (C D E)
----

LISP programmers back then read and wrote programs in this form,
_on paper_.  Yes, program sources were meant to be read by humans.
In order for computers to understand programs, one must have prepared
a deck of cards, each of which had holes punched according to
link:https://en.wikipedia.org/wiki/BCD_(character_encoding)[BCD character code].
The character set didn't have many punctuations and it was impossible
to punch M-expressions directly.  Instead, people translated
M-expressions into S-expressions, which was already used
to describe nested list structures.  In other words, people
fed the machine the internal representation of syntax tree
directly.

Eventually, people got used to write programs in S-expresions
and M-expressions were faded into oblivion.

However, when we read papers of that era, we see M-expressions
everywhere.  Now that we can write M-expressions in a text file,
let's make the computer understand it directly!

=== M-expression syntax

Here's a summary of M-expression sytnax:

- Identifiers are in all lowercase.  Literal symbols are in all uppercase.
  No `quote` in M-expression.  Literal list can be written using parentheses,
  e.g. `(A B (C D . E))`, without a quote.
- Function call is written as `fn[arg1;arg2;...]`
- Conditional is `[test1 \-> expr1; test2 \-> expr2;...]`.  It works just like
  `cond`.   Unicode arrow character `->` (U+2192) can be used in place of `\->`.
- Symbol `NIL` is used for list terminator.  Hence `cons[A;NIL]` yields
  `(A)`.
- Literal function is written as `lambda[[arg;..];expr]`.  This lambda form
itself doesn't have a value -- it must be called with arguments to take effect.
- Local recursive function can be written as `label[name;lambda[[arg;...];expr]]`,
where you can use `name` in the `expr` to refer to itself.
- In toplevel, you can define a function by `name[arg;...] = expr`.

An M-expression can be translated into an S-expression as follows:

- Literal data (symbols and lists) are embedded in the output
by `(QUOTE <literal>)`.
- Function call `fn[arg1;arg2;...]` becomes (FN ARG1 ARG2 ...)`.
We didn't have lower case characters on computers back then.
- Conditional `[test1 \-> expr1; test2 \-> expr2;...]` becomes
`(COND (TEST1 EXPR1) (TEST2 EXPR2) ...)`.
- Literal function `lambda[[arg;..];expr]`
becomes `(LAMBDA (ARG ...) EXPR)`.
- Local recursive function `label[name;lambda[[arg;...];expr]]`
becomes `(LABEL NAME (LAMBDA (ARG ...) EXPR))`.

=== Parsing single M-expression

Module `LISP1.5.mexpr` implements parsers.  A procedure
`parse-mexpr` takes a string or an input port, and parses one M-expression
and returns an S-expression.

----
gosh> ,u LISP1.5.mexpr
gosh> (parse-mexpr "cons[(A . B);C]")
(CONS (QUOTE (A . B)) (QUOTE C))
gosh> (parse-mexpr "lambda[[x];[eq[NIL;x]→T; T→F]]")
(LAMBDA (X) (COND ((EQ (QUOTE NIL) X) (QUOTE T)) ((QUOTE T) (QUOTE F))))
----

See how liteals (upper-case names and lists) are `QUOTE`{nbsp}-d
once parsed.

[TIP]
======================================================
If you try the above example on your REPL, make sure
your terminal character encoding matches your Gauche setting
(it's utf-8 by default).
======================================================

Interestingly, there seemed no direct translation of definition
syntax `name[arg;...] = expr` into an S-expression.
When a user translates a prorgam in M-expressions into S-expressions
to punch the cards,
she gathers all the definitions into a call of `DEFINE` pseudo function
(see the note below).

For our purpose, we want the parser to yield a single S-expression
from one M-expression.  So, we return `($= ...)` form
as the result of parsing a defintion:

----
gosh> (parse-mexpr "null[x] = [eq[NIL;x]→T; T→F]]")
($= (NULL X) (COND ((EQ (QUOTE NIL) X) (QUOTE T)) ((QUOTE T) (QUOTE F))))
----

(The preceding `$` of `$=` indicates it is an internal or 
implementation-dependent feature.)

The `parse-mexpr` function only parses one M-expression.
If the input may contain more than one M-expression, use `parse-mexprs`
instead, which reads input up to EOF and returns an lseq of result
S-expressions.

=== Writing source in M-expression:

For our purpse, we want to treat M-expressions as our source code,
and the parser returns a single S-expression as a result.
So we introduce our own extension.

----
($TOPLEVEL <toplevel-form> ...)

<toplevel-form> : (= <expr> <expr> [<key>])
                | <expr>
----

When read, the entire source is wrapped in `$TOPLEVEL` form.
Inside it, each toplevel form becomes either
`(= <expr> <expr>)` (in case of definition) or just an `<expr>`
in case of toplevel function call.  This `TOPLEVEL` form is
merely our parser's way to wrap the result, and its interpretation
depends on the caller of the parser; it doesn't mean we'll have
a special form called `TOPLEVEL`.

[NOTE]
================================================================
In the actual use case, all definitions in a program were
gathered and translated into the following form to be punched:

----
DEFINE ((
(NAME (LAMBDA (ARG ...) EXPR))
(NAME (LAMBDA (ARG ...) EXPR))
...
))
----

This is actially a special syntax to execute a function call on toplevel.
It takes a form `FUNC (ARG ...)`, where `ARG`{nbsp}s are implicitly
kxkxquoted.  The function `DEFINE` takes one argument, which is
a form of `((NAME LAMBDA-EXPR) ...)`.

If you want to perform some calculation, you list the call of
the function after the `DEFINE` form, as follows:

----
DEFINE ((
 ... definitions ..
(DOIT (LABMDA (ARG ...) EXPR))   
))

DOIT (ARG ...)
----

Examples are shown in p.15 and pp.48-51 of LISP1.5 Programmer's
Manual.
================================================================

You can write M-expression in Scheme source code using `#!m-expr` directive.

----
;;
;; Scheme comments
;; 
(use LISP1.5.mexpr)
#!m-expr

# M-expression function definitions
function1[arg;...] = expression1
function2[arg;...] = expression2
...
----

The `#!m-expr` directive translates those M-expressions into
a LISP1.5 `DEFINE` form:

----
($TOPLEVEL
 ($= (FUNCTION1 ARG ...) EXPRESSION1)
 ($= (FUNCTION2 ARG ...) EXPRESSION2)
  ...)
----

Note that you have to have definitions of `DEFINE` and other primitive
LISP1.5 forms before loading the source file; The `LISP1.5.mexpr` module
only handles parsing.

We provide several implementations of those LISP1.5 primitives,
which we'll show you in the following chapters.


=== Other exhancements

We also add these extensions, for the convenience.

==== Comments

There's no comment syntax defined in M-expressions, since
it's for humans to read, you can freely intermix code
and natural language descriptions.  For our purpose,
we make a hash sign `#` to the end of line is a comment.
(We avoid `;`, for it is used as a separator.)

==== Extended `COND` form

In Appendix B of LISP 1.5 Programmer's Manual, they use
a pseudo extension of conditional expression for concise
explanation.  Such extension didn't formalized and the actual
code is written in assembly language instead of M-expressions.
But for our purpose it'll be convnient to support such extension.
It is to allow a conditiona expression to have the following clause:
----
test \=> fun

where fun can be an expression that yield a function,
or a LAMBDA form.
----
First, `test` is evaluated, and if it yiels a true value
(a value neither `NIL` nor `F`), the value is applied to
the function.  It's the same as Scheme's `cond` feature with `\=>`.



== A Universal LISP Function

=== Running EVAL with minimal axioms

Section 1.6 of "LISP 1.5 Programmer's Manual" is one of the pinnacles
of the document.  They show how to implement Lisp interpreter
on top of Lisp systems.  They call it "a Universal LISP function".

We write out their code in link:mx/eval.mx[].

What's interesting about it is that you only need a handful of
functions and syntaxes to run the interpreter.  We define those
minimal set of primitives in link:LISP1/5/axioms.scm[].
It provides the definition of the following primitives:
`CAR`, `CDR`, `CONS`, `ATOM`, `EQ`, `QUOTE`, `COND`, and `DEFINE`.

To try the eval function, first `use` the axioms module, then
load the `eval.mx` file.  Assuming you have
load path set to the top directory of LISP1.5 source,
you can say the following in the gosh REPL:

----
gosh> ,u LISP1.5.axioms
gosh> ,l mx/eval.mx
#t
----

Or, you can start gosh with loading necessary modules
(this assumes you're in the top directory of LISP1.5 source):

----
$ gosh -I. -u LISP1.5.axioms -l mx/eval.mx
----

On the gosh prompt, you can call `EVAL`.  The first argument
is the S-expression to evaluate, and the second argument
is the environment (assoc list of symbols and values):

----
gosh> (EVAL '(CONS (CAR (QUOTE (X . Y))) (QUOTE Z)) 'NIL)
(X . Z)
----

Be aware of the difference of `'` (`quote`) and `QUOTE`.
The former one is recognized by Gauche.  The latter one is recognized by
`EVAL`.

If you prefer, you can write M-expressions using
read-time constructor `#,(m-expr "...")`:

----
gosh> (EVAL '#,(m-expr "cons[car[(X . Y)];Z]") 'NIL)
(X . Z)
----

Following is a bit more convoluted example.  It defines `append`
as a recursive funciton using `LABEL`, and calls it with
two arguments, `(A B C)` and `(X Y Z)`:


----
gosh> (EVAL '#,(m-expr "label[append;lambda[[xs;r];\
                               [eq[xs;NIL] -> r;\
                                T -> cons[car[xs];append[cdr[xs];r]]]]]\
                        [(A B C);(X Y Z)]")
            'NIL)
(A B C X Y Z)
----

This interpreter only _knows_ the minimal 7 primitives:
`CAR`, `CDR`, `CONS`, `ATOM`, `EQ`, `QUOTE`, and `COND`.
To refer to anything other than that, 
you have to pass them in the environment argument.

The following example reverses a list, using the
definition of `NULL`, `APPEND` and `REVERSE` given to the environment:

----
gosh> (EVAL '#,(m-expr "reverse[(A B C D E F G)]")
            '((NULL . #,(m-expr "lambda[[x];[eq[x;NIL] -> T; T -> F]]"))
              (APPEND . #,(m-expr "lambda[[xs;r];\
                                     [eq[xs;NIL] -> r;\
                                      T -> cons[car[xs];append[cdr[xs];r]]]]"))
              (REVERSE . #,(m-expr "lambda[[xs];\
                                      [null[xs] -> NIL;\
                                       T -> append[reverse[cdr[xs]];cons[car[xs];NIL]]]]"))
             ))
(G F D C B A)
----

[NOTE]
================================================================
We need to provide the function `NULL` in the environment, 
since the one defined in `eval.mx` exists in the world of Gauche, and is
not visible from the world of `EVAL`.
================================================================

[TIP]
================================================================
When you refer to an identifier that's neither one of the built-in
primitive nor the one given in the environment, you'll get an error
like the following:

----
*** ERROR: pair required, but got NIL
Stack Trace:
_______________________________________
  0  (car x)
        at "./LISP1/5/axioms.scm":9
  1  (CAR X)
        [unknown location]
  2  (CAAR A)
        [unknown location]
  3  (EQUAL (CAAR A) X)
        [unknown location]
  4  (ASSOC E A)
        [unknown location]
  5  (EVAL FN A)
        [unknown location]
...
----

The code searches the environment alist by `ASSOC`, hits the end of
the alist without finding it and complains.  Remember, we have minimal
interpreter and there's no fancy error handling mechanism.
================================================================


=== Going Metacircular

Since the universal LISP function defined in `eval.mx` understands
the primitives required to interpret functions in `eval.mx`, you can use
our `EVAL` to evaluate `eval.mx` to run `EVAL` on top of 
`EVAL` -- now you're running a metacircular interpreter!

You might have noticed though, that `axioms.scm` provides `DEFINE`,
which is missing in `eval.mx`.  In our context of discussing
metacircular interpreter, `DEFINE` appears as a result of
parsing M-expression definitions, and should be understood
as a meta-language to direct the set-up, rather than an integrated
part of the language (one way to think of it is that if other primitives
are C built-ins then `DEFINE` is `#pragma` or `Makefile` -- they belong
to a slightly different layer.)

Of course, it is more convenient to include `DEFINE` in the core language,
and we'll deal with it later.  For now, let's stick to the primitives
excluding `DEFINE`.

In order to run `EVAL` inside `EVAL`, we need to prepare the definitions
in `eval.mx` as an environment alist passed to outer `EVAL`.
Run the following command in the toplevel source directory:

----
$ gosh tools/mexpr-env.scm mx/eval.mx
----

It reads `eval.mx` and prints the definitions in an alist.  Copy the output,
then start `gosh` again, read `axioms` and load `eval.mx`, and evaluate
the `EVAL` expression, passing the copied alist as the environment
(don't forget the quote before the alist!):


----
gosh> ,u LISP1.5.axioms
gosh> ,l mx/eval.mx
#t
gosh> (EVAL '(EVAL (QUOTE (CAR (QUOTE (X . Y)))) (QUOTE NIL))
            '...<<here, copy & paste the output of mexpr-env.scm>>)
X
----

The result `X` is the result of `(CAR (QUOTE (X . Y)))`, computed
by the `EVAL` function implemented in LISP1.5, not the underlying Gauche.

If cut&pasting the environment alist is too tedious, `mexpr-env.scm` can
create a definition of an auxiliary function `EVAL*`, which calls `EVAL`
with the environment that has all the definitions in the given source file.
Run `mexpr-env.scm` with `-e` option, and save the result in `lisp/eval.lisp`:

----
$ gosh tools/mexpr-env.scm -e mx/eval.mx > lisp/eval.lisp
----

[TIP]
==================================================================
Instead of manually executing `tools/mexpr-env.scm`, you can
run the standard build process (`./configur && make`) and
all the converted files are placed under `lisp/`.
==================================================================


We use suffix `lisp` to indicate it is not a Scheme code (even though
Gauche can understand it after using `LISP1.5.axioms`).
The created `lisp/eval.lisp` looks as follows:

----
(DEFINE ((EVAL* (LAMBDA (X) (EVAL X '...<<environment defined in eval.mx>>...
)))))
----

That is, it defines `EVAL*` which takes one LISP1.5 expression and
evaluates it under the enviornment where all the definitions in `eval.mx`
is visible.

The created `eval.lisp` can be loaded to `gosh` after using `LISP1.5.axioms`.  
Together with `mx/eval.mx`, you can run `EVAL` on top of `EVAL`:

----
$ gosh -I. -uLISP1.5.axioms -lmx/eval.mx -leval-star.lisp
gosh> (EVAL* '#,(m-expr"eval[(CONS (QUOTE X) (QUOTE Y));NIL]"))
(X . Y)
----

This time we used M-expression in the inner call.  It's the same
as writing `'(EVAL (QUOTE (CONS (QUOTE X) (QUOTE Y))) (QUOTE NIL))`.

Let's recap what's happening.  The outer `EVAL` (via `EVAL*`) is
executed by Gauche, using the initially loaded `eval.mx`.  The
inner `EVAL` is interpreted by the outer `EVAL`, using the
enviornment created by `mexpr-env.scm`.
And the expression `(CONS (QUOTE X) (QUOTE Y))` is interpreted by
the inner `EVAL`:

----
        +----------------------------+
        | (CONS (QUOTE X) (QUOTE Y)) |
        +----------------------------+
        |           EVAL             |  ; inner EVAL
        +----------------------------+
        |           EVAL             |  ; outer EVAL
        +----------------------------+
        |          Gauche            |
        +----------------------------+
----

If it is not obvious, try it with an altered environment.
For example, edit the `eval.lisp` created above
to change the inner `EVAL` recognizes `KWOTE` instead of `QUOTE`.
There's only one place to change:

----
 (EVAL
  LAMBDA
  (E A)
  (COND
   ((ATOM E) (CDR (ASSOC E A)))
   ((ATOM (CAR E))
    (COND ((EQ (CAR E) (QUOTE KWOTE)) (CADR E))
                              ^^^^^
     ((EQ (CAR E) (QUOTE COND)) (EVCON (CDR E) A))
     ((QUOTE T) (APPLY (CAR E) (EVLIS (CDR E) A) A))))
   ((QUOTE T) (APPLY (CAR E) (EVLIS (CDR E) A) A))))
----

(Leave other `QUOTE` intact, for they are recognized by the outer `EVAL`).

Now, try it:

----
(EVAL* '(EVAL (QUOTE (CONS (KWOTE X) (KWOTE Y))) (QUOTE NIL)))
  => (X . Y)
----

The two `QUOTE`{nbsp}s are recognized by the outer `EVAL`, and the two
`KWOTE`{nbsp}s are recognized by the inner `EVAL`.  Furthermore,
the `'` (`quote`) is recognized by Gauche.


=== Having FUN with ARG

(If you know what we'll talk about from the section title, you can
skip this section.  Yes, it's just about _that_.)

One advantage of having a simple language with a concise interpreter is
that we can tweak it easily.

In the universal `EVAL`, a function is represented as a literal list
whose car is `LAMBDA`.  It is a powerful idea--now you can have
a function as a first-class citizen of the language, that you can
construct it, pass it to another function, and return it from another
funciton.  However, it has a flaw.

Let's try a failure case and see if we can fix it.

Consider `MAPCAR` function, which takes a function and a list, and
returns a list of results of the function applied to each element of the
given list (that is, Scheme's `map` function):

----
mapcar[fn;x] = [null[x] -> NIL;
                T -> cons[fn[car[x]];mapcar[fn;cdr[x]]]]
----

It is in link:mx/mapcar.mx[].  You can't load it directly
into Gauche, however.  Treating a list starting with `LAMBDA` as
a function is a feature of `EVAL`, not Gauche.  
We have to make `EVAL` understand the above definition.

We can use the same technique we used in the metacircular interpreter --
that is, translate the definition of `MAPCAR` above into an enviroment
alist.  We also need the definition of `NULL`, so let's combine
`eval.mx` together with `mapcar.mx`.  It can be done with the following
command line:

----
$ gosh tools/mexpr-env.scm -e mx/eval.mx mx/mapcar.mx > lisp/mapcar.lisp
----

Alternatively, run `./configure` then `make` in the toplevel source directory.

Once you have `lisp/mapcar.lisp`, you can load it (after `mx/eval.mx`)
and you can call `MAPCAR` inside `EVAL*`:

----
$ gosh -I. -uLISP1.5.axioms
gosh> ,l mx/eval.mx
#t
gosh> ,l lisp/mapcar.lisp
#t
gosh> (EVAL* '(MAPCAR (QUOTE (LAMBDA (X) (CONS X (QUOTE Y)))) (QUOTE (A B C))))
((A . Y) (B . Y) (C . Y))
gosh> (EVAL* '#,(m-expr "mapcar[(LAMBDA (X) (CONS X (QUOTE Y)));(A B C)]"))
((A . Y) (B . Y) (C . Y))
----

So far, so good.

Now, Let's try nesting `MAPCAR`.  We'll do equivalent to the following
Scheme code:

----
(map (lambda (x) (map (lambda (y) (cons x y)) '(p q r))) '(a b c))
  => (((a . p) (a . q) (a . r)) ((b . p) (b . q) (b . r)) ((c . p) (c . q) (c . r)))
----

Here's LISP1.5 version:

----
(EVAL* '(MAPCAR (QUOTE (LAMBDA (X)
                         (MAPCAR (QUOTE (LAMBDA (Y) (CONS X Y)))
                                 (QUOTE (P Q R)))))
                (QUOTE (A B C))))
  => ((((P Q R) . P) ((Q R) . Q) ((R) . R)) (((P Q R) . P) ((Q R) . Q) ((R) . R)) (((P Q R) . P) ((Q R) . Q) ((R) . R)))
----

Oops, what happened?  Let's examine the details.
Outer `MAPCAR` receives two actual parameters, `(LAMBDA (X) ...)` and `(A B C)`
(`QUOTE`{nbsp}s are stripped when arguments are evaluated
by `evlis` before calling the function).   They are bound to the
local parameters, `FN` and `X`, respectively.  In other words,
the body of `MAPCAR`:

----
[null[x] -> NIL;
 T -> cons[fn[car[x]];mapcar[fn;cdr[x]]]]
----

is evaluated with the following environment:

----
((FN . (LAMBDA (X)
         (MAPCAR (QUOTE (LAMBDA (Y) (CONS X Y)))
                 (QUOTE (P Q R)))))
 (X . (A B C)))
----

Since `X` is not `NIL`, evaluation goes to `cons[...]` branch.
The first argument is `fn[car[x]]`, so first `car[x]` is evaluated
and yields `A`, `fn` evaluated to the outer `LAMBDA` form
and we call it with `A`.  The body of inner `LAMBDA` form, which
is the inner `MAPCAR` call, is evaluated with the following environment
(Keep in mind that the new local bindings are inserted in front of
outer environment):

----
((X . A)
 (FN . (LAMBDA (X)
         (MAPCAR (QUOTE (LAMBDA (Y) (CONS X Y)))
                 (QUOTE (P Q R)))))
 (X . (A B C)))
----

Inner `MAPCAR` gets `(LAMBDA (Y) (CONS X Y))` and `(P Q R)` as two
actual parameters, which are bound to `MAPCAR`{nbsp}'s formal paramter
`FN` and `X` again, and the environment under which innter `MAPCAR`{nbsp}'s
body is evaluated looks like this:

----
((FN . (LAMBDA (Y) (CONS X Y)))
 (X . (P Q R))
 (X . A)
 (FN . (LAMBDA (X)
         (MAPCAR (QUOTE (LAMBDA (Y) (CONS X Y)))
                 (QUOTE (P Q R)))))
 (X . (A B C)))
----

Finally, innter `LAMBDA` is called -- first, `P` as the
actual parameter, which is bound to `Y`.  Hence the body
of the inner `LAMBDA`, which is `(CONS X Y)`, is evaluated
under the following environment:

----
((Y . P)
 (FN . (LAMBDA (Y) (CONS X Y)))
 (X . (P Q R))                                <1>
 (X . A)                                      <2> 
 (FN . (LAMBDA (X)
         (MAPCAR (QUOTE (LAMBDA (Y) (CONS X Y)))
                 (QUOTE (P Q R)))))
 (X . (A B C)))                               <3>
----

1. Argument for the inner `MAPCAR`
2. Argument for the outer `LAMBDA`
3. Argument for the outer `MAPCAR`

Now it is clear why it didn't work.   When we write the
initial nested `MAPCAR` form, we expect that `X` in the
innermost expression `(CONS X Y)` refer to the formal parameter of the
outer `LAMBDA`.  But it is shadowed by the formal parameter of the
`MAPCAR`.

This is a well-known problem, and in lambda calculus it is avoided
by _renaming_ the parameter names to avoid conflict.  In our case,
if we rename the formal parameter of inner `LAMBDA` to something
different from the formal parameter of `MAPCAR`, it works as expected:

----
(EVAL* '(MAPCAR (QUOTE (LAMBDA (Z)                                  <1>
                         (MAPCAR (QUOTE (LAMBDA (Y) (CONS Z Y))) 
                                 (QUOTE (P Q R)))))
                (QUOTE (A B C))))
 => (((A . P) (A . Q) (A . R)) ((B . P) (B . Q) (B . R)) ((C . P) (C . Q) (C . R)))
----

1. We use `Z` to avoid confclit with `MAPCAR`{nbsp}'s `X`.

However, we can't possibly avoid all potential conflict manually,
and renaming all formal parameters programatically to unique ones can be costly.

LISP1.5 employed another way to solve this problem.  Instead of passing
`LAMBDA` form quoted, it introduced another form, called `FUNCTION`.
The rule is that whenever you pass a function as an argument,
you wrap it with `FUNCTION` instead of `QUOTE`.  With this rule,
our call of nested `MAPCAR` would look like this:

----
(EVAL* '(MAPCAR (FUNCTION (LAMBDA (X)
                            (MAPCAR (FUNCTION (LAMBDA (Y) (CONS X Y))) 
                                    (QUOTE (P Q R)))))
                (QUOTE (A B C))))
----

Now we modify our universal LISP function to deal with `FUNCTION`.
We only need to change two lines.  First, make `EVAL` understand
`(FUNCTION <fn>)` form.  Whenver it sees the form, it just
returns a list `(FUNARG <fn> <env>)`, where `<env>` is the evaluation
enviornment:

----
eval[e;a] =
  [atom[e] -> cdr[assoc[e;a]];
   atom[car[e]] -> [eq[car[e];QUOTE] -> cadr[e];
                    eq[car[e];FUNCTION] -> cons[FUNARG;cons[cadr[e];cons[a;NIL]]]; <1>
                    eq[car[e];COND] -> evcon[cdr[e];a];
                    T -> apply[car[e];evlis[cdr[e];a];a]];
   T -> apply[car[e];evlis[cdr[e];a];a]]
----

1. If we see `(FUNCTION <fn>)` form, wrap the function and the current environment in `FUNARG` form, as `(FUNARG <fn> <env>)`.


Then, in `APPLY`, we call `<fn>` with the rememberd `<env>` instead of
the passed environment:

----
apply[fn;x;a] =
  [atom[fn] -> [eq[fn;CAR] -> caar[x];
                eq[fn;CDR] -> cdar[x];
                eq[fn;CONS] -> cons[car[x];cadr[x]];
                eq[fn;ATOM] -> atom[car[x]];
                eq[fn;EQ] -> eq[car[x];cadr[x]];
                T -> apply[eval[fn;a];x;a]];
   eq[car[fn];FUNARG] -> apply[cadr[fn];x;caddr[fn]];                  <1>
   eq[car[fn];LAMBDA] -> eval[caddr[fn];pairlis[cadr[fn];x;a]];
   eq[car[fn];LABEL] -> apply[caddr[fn];x;cons[cons[cadr[fn];caddr[fn]];a]]]
----

1. Apply the wrapped function in the rememberd environment


The changed definitions are in link:mx/funarg.mx[].  You can load it
and see it addresses the issue (which has been called FUNARG problem).

----
$ gosh -I. -u LISP1.5.axioms -l mx/funarg.mx
gosh> ,l lisp/mapcar.lisp
#t
gosh> (EVAL* '(MAPCAR (FUNCTION (LAMBDA (X)
                         (MAPCAR (FUNCTION (LAMBDA (Y) (CONS X Y)))
                                 (QUOTE (P Q R)))))
                (QUOTE (A B C))))
(((A . P) (A . Q) (A . R)) ((B . P) (B . Q) (B . R)) ((C . P) (C . Q) (C . R)))
----

[NOTE]
==========================================================
Did you notice that you actually did't need `FUNCTION`?  Instead
of introducing another form, you can let `EVAL` create `FUNARG`
when it sees a bare `LAMBDA` form.  The definition will look like this:

----
eval[e;a] =
  [atom[e] -> cdr[assoc[e;a]];
   atom[car[e]] -> [eq[car[e];QUOTE] -> cadr[e];
                    eq[car[e];LAMBDA] -> cons[FUNARG;cons[e;cons[a;NIL]]];
                    eq[car[e];COND] -> evcon[cdr[e];a];
                    T -> apply[car[e];evlis[cdr[e];a];a]];
   T -> apply[car[e];evlis[cdr[e];a];a]]
----

The updated definition is in link:mx/funarg-lambda.mx[].  Using it,
calling `MAPCAR` becomes quite simpler:

----
$ gosh -I. -u LISP1.5.axioms -l mx/funarg-lambda.mx
gosh> ,l lisp/mapcar.lisp
#t
gosh> (EVAL* '(MAPCAR (LAMBDA (X)
                        (MAPCAR (LAMBDA (Y) (CONS X Y))
                                (QUOTE (P Q R))))
                      (QUOTE (A B C))))
(((A . P) (A . Q) (A . R)) ((B . P) (B . Q) (B . R)) ((C . P) (C . Q) (C . R)))
----

This idea was realized by Sussman and Steele in 1975, as a dialect
Scheme.  The first paper of Scheme stated it at the beginning:

[quote, Gerald Jay Sussman and Guy Lewis Steele Jr., 'SCHEME: An Interpreter For Extended Lambda Calculus']
----
SCHEME is essentially a full-funarg LISP.  LAMBDA expressions need
not be QUOTEd, FUNCTIONed, or *FUNCTIONed when passed as arguments or
returned as values; they will evaluate to closures themselves.
----

==========================================================


=== Symbols and toplevel environment

So far, our `EVAL` requires any bindings to be provided
via the environment argument.  Preprocessing the source with `mexpr-env.scm`
was a remedy, but it's still troublesome.  So our next step is to
add a toplevel environment, that keeps global bindings of `DEFINE`{}d
symbols.

The easiest way is to keep a global table, and when we search
a variable binding via `ASSOC` (in the first branch of `EVAL`),
we also look up the table when we didn't find any local bindings.

However, LISP1.5 took a bit different approach. Since its symbol had
a property list, or _plist_, which could hold arbitrary key-value
pairs, so I suspect it was natural to store the global value
of the symbol in its plist.  In fact, even the name of a symbol
was merely one of its properties.  In LISP1.5, a symbol was just
another type of list where the car of its head was marked
with a special value (-1).

[NOTE]
====
A property list (plist) associates keys to values, much like
an associative list (alist),
but its structure alternates keys and values.  For example, if
key `A` has value `APPLE` and key `B` has a value `BANANA`, it can
be represented with the following alist and plist, respectively:

----
;; alist
((A . APPLE) (B . BANANA))

;; plist
(A APPLE B BANANA)
----

The number of cons cells used are the same.  We're not sure why LISP1.5
creators used plist for symbol properties, while they used
alist for environment in `EVAL`.
====

In our minimal infrastructure (link:LISP1/5/axioms.scm[]) we just
used Gauche symbols for LISP symbols.  It might be interesting,
though, to reproduce what LISP1.5 did -- using a list to implement
symbols!

That is, from now on, our LISP symbol is a pair whose car is
a special marker.  We use Gauche symbol `ATOM`.  From LISP world,
a LISP symbol is an unbreakable unit (hence it is called _atom_), so
the marker is never be visible.  Under the hood, in Gauche level,
we can break an atom to access its internal structure.  It is as
if LISP world deals with chemical reactions and Gauche world deals
with nuclear reactions.

In LISP symbols, its name is stored as a value of the property
`PNAME`.  Since the property list is scanned by LISP function,
we have to use LISP symbols as the property key.  For the name itself,
we use a Scheme string; in real LISP1.5, the name is stored
in a special way and treated specially (there wasn't a string type).

Thus, LISP symbol `PNAME` has the following structure in Gauche:

[source, scheme]
----
(define *PNAME* '#0=(ATOM #0# "PNAME"))
----

The `#0=` notation is a Scheme way to write a circular structure.
The symbol `PNAME` has a propoerty list, in which the key `PNAME`
is associated to the name `"PNAME"`.   Note that they LISP symbol
`PNAME` itself doesn't have a global value.

The global value of symbols is stored as a propery value with
the key `APVAL`.  So we need the LISP symbol `APVAL`, which looks
like the following in Gauche.  `APVAL` itself doesn't have a global
value either:

[source, scheme]
----
(define *APVAL* `(ATOM ,*PNAME* "APVAL"))
----

Once we have `PNAME` and `APVAL`, we can define `NIL`, whose name
is `"NIL"` and value is itself.  We can't use `#0=` notation this time,
since we have to construct the list using values of `\*PNAME\*` etc.

[source, scheme]
----
(define *NIL* (rlet1 nil (list 'ATOM *PNAME* "NIL" *APVAL*)
                (set! (cddddr nil) (list nil))))
----

Here's how `\*NIL\*` looks like in Gauche world.
`#1=(ATOM #1# "PNAME")` is LISP symbol `PNAME`, and
`(ATOM #1# "APVAL")` is LISP symbol `APVAL`.  Remember we're looking
at the internal of atoms -- from LISP world, this is just a symbol
`NIL`.

----
gosh> *NIL*
#0=(ATOM #1=(ATOM #1# "PNAME") "NIL" (ATOM #1# "APVAL") #0#)
----

We can define several symbols in this way.  See link:LISP1/5/runtime.scm[]
for all the predefined symbols.

Let's start building infrastructure.  Our LISP world only have symbols
and cons cells so far (we'll add numbers later).  We can define `$atom?`
and `$cons?` as follows (The `$` indicates it deals with LISP objects):

[source, scheme]
----
(define ($atom? obj) (and (pair? obj) (eq? (car obj) 'ATOM)))
(define ($cons? obj) (and (pair? obj) (not (eq? (car obj) 'ATOM))))
----

Then we can define `$lisp\->scheme`, which converts LISP data structure
into Scheme data structure, handy for debugging.
We map `NIL` inside the structure into Scheme empty list, so that
list structure can be printed naturally (instead of having `. NIL)`
at the end.)  We also convert non-LISP object into a string `#[...]`.

[source, scheme]
----
(define ($lisp->scheme obj)
  (define (rec obj)
    (cond [(eq? obj *NIL*) '()]
          [($atom? obj) (string->symbol (cadr (member *PNAME* (cdr obj))))]
          [(pair? obj) (cons (rec (car obj)) (rec (cdr obj)))]
          [else (format "#[~s]" obj)]))
  (if (eq? obj *NIL*)
    'NIL
    (rec obj)))
----

It's also handy to have `$scheme\->lisp`, which converts Scheme
structure into LISP structure.   One important point: We want to keep
symbol's `eq`{nbsp}-ness, that is, LISP symbols with the same name
can be compared with `eq`.  So we keep a hashtable to map Scheme
symbol to LISP symbols.

[source, scheme]
----
(define *obtable* (hash-table-r7 eq-comparator
                                 'NIL *NIL*
                                 'PNAME *PNAME*
                                 'APVAL *APVAL*))

(define ($scheme->lisp obj)
  (cond [(null? obj) *NIL*]
        [(symbol? obj) (or (hash-table-get *obtable* obj #f)
                           (rlet1 s (list 'ATOM *PNAME* (symbol->string obj))
                             (hash-table-put! *obtable* obj s)))]
        [(pair? obj) (cons ($scheme->lisp (car obj))
                           ($scheme->lisp (cdr obj)))]
        [else (errorf "Cannot convert ~s to LISP" obj)]))
----

Let's try them.  Converting Scheme `(A B C D E)` into LISP results
somewhat scary structure, but converting it back shows it's nothing
to be afraid of:

----
gosh> ($scheme->lisp '(A B C D E))
((ATOM #0=(ATOM #0# "PNAME") "A") (ATOM #0# "B") (ATOM #0# "C")
 (ATOM #0# "D") (ATOM #0# "E") . #1=(ATOM #0# "NIL" (ATOM #0# "APVAL") #1#))
gosh> ($lisp->scheme *1)
(A B C D E)
----

Not all global values are stored in `APVAL` property.  LISP1.5 uses
several different keys, depending on the type of the value.  `APVAL`
is used when a symbol is used as a variable, and other keys are
used when a symbol is used in the function position of the function call.

[%header,cols=2*]
|===
| Key
| Value

|`APVAL`
|The value is a LISP object.

|`EXPR`
|The value is a LISP-defined function (LAMBDA or FUNARG form).  The arguments
are evaluated before passed to it.

|`FEXPR`
|The value is a LISP-defined function (LAMBDA or FUNARG form).  The arguments
are not evaluated, and passed as a single list.

|`SUBR`
|The value is a native function (written in assembly in the acutal LISP1.5,
written in Gauche in our case).  The arguments are evaluated before
passed it.

|`FSUBR`
|The value is a native function (written in assembly in the acutal LISP1.5,
written in Gauche in our case).  The arguments
are not evaluated, and passed as a single list.
|===

It is worth to mention that EXPR form receives fixed-number of arguments.
If you want to write a function in LISP that takes variable number
of arguments, you have to make it FEXPR, and evaluate the given list
of arguments by yourself.

[NOTE]
============================================================
Lisp dialects can be categorized to either Lisp-1 or Lisp-2.
They are not versions, but about namespaces.

Lisp-1 unifies function and variable namespaces, so in the 
function call syntax, the function name is looked up the same
way as variable look-up.  Scheme is Lisp-1.

Lisp-2 have separate namespaces for functions and variables.
You can use the argument named `list`, and it is treated separately
from the function `list`.  When you need to call a function stored
in a variable, you need to use an extra function, `funcall`.
Common Lisp is Lisp-2.

This design of having different keys for function call and
variable makes LISP1.5 a Lisp-2.  However, interestingly,
to call a function stored in a variable you can place the variable
in the function position, without `funcall`, just like Scheme.
So, coincidentally, we can say LISP1.5 is somewhat between Lisp-1 and Lisp-2.
============================================================


=== Bridging worlds

As we did in our first version with link:LISP1/5/axioms.scm[axioms.scm] and
link:mx/eval.mx[eval.mx], we want to keep Scheme code minimal
and write the rest of the system in LISP itself.  We also want to
write so-called standard libraries in LISP, too.

When you write language X in the language X itself, you have to be
epecially careful which _world_ you're dealing with.  Before proceeding,
let's recap the layered structure we saw in the previous sections.

* In `axioms.scm`, we defined minimal operators in Scheme to run LISP 1.5.
It is the bottom world, or the Basement.  We can see all the mechanics
that runs the LISP system from the Basenment.

* Then we loaded `eval.mx`, which is written in LISP 1.5 itself.  At this
time though, the functions in `eval.mx`, such as `NULL`, `ASSOC` or
`EVAL`, are actually Gauche variables, bound to Gauche procedures;
The `DEFINE` macro in `axioms.scm` translates LISP 1.5 definitions
into Gauche definitons.  The functions in `eval.mx` doesn't know
about Gauche, even though they themselves are running as Gauche procedures.
We're in the Ground Floor.

* Then we processed `eval.mx` with `mexpr-env.scm` to produce `eval.lisp`.
It has `EVAL*`, which is still Ground Floor function.  It takes a LISP1.5
expression and evaluates it.  The expression passed to `EVAL*` lives
in the First Floor, above the Ground Floor.  As we've seen,
the habitants in the First Floor knows nothing about the Ground Floor
or the Basement, except the bindings passed as the environment.

Now, in our revised runtime, difference between the Basement
and the Ground Floor becomes wider: A LISP symbol is an unbreakable
atom in the Ground Floor, but it's just a pair in the Basement.
But we want to relax the abstraction barrier between the Grand Floor
and the First Floor.  Here's why:

We're going to write a revised `EVAL` that can deal with LISP symbols
and global binding, so we write several supporting functions to
set and get symbol's attributes.  Those functions live in the Ground Floor.








== Building a machine

In the previous section we showed we can run a complete LISP interpreter
on top of a handful of primitive operators.
Providing those operators are link:LISP1/5/axioms.scm[incredibly easy] -- only
a half page of code can bootstrap Lisp!

Well, there's an important omission.  To provide `CONS`, for example,
you have to allocate a piece of memory somewhere.  
To read and write M- or S-expressions,
you need I/O.  In link:LISP1/5/axioms.scm[], we just put those work
on Gauche runtime.  Isn't it a kind of cheat?  Don't you want to
know what it _really_ takes to build a LISP system from scratch?

Well then, let's do that!

=== Memory model

We start from the memory.

IBM704, on which LISP was first developed, was a 36-bit machine.
Its memory was basically an array of 36-bit words -- each address
can hold a word, not an 8-bit byte.
Each word can be broken up to 4 parts:
3-bit _prefix_, 15-bit _decrement_, 3-bit _tag_, and 15-bit _address_.
The memory can be fully accessed with 15-bit address, so each word
can have two pointers.
`CAR` and `CDR` came from _contends of address part of register_ and
_contents of decrement part of register_.
I suspect that this architecture of IBM704
influenced the design of LISP using two-pointer cells (_cons cells_)
for almost everything.

To store characters, a word is viewed as a chunk of six 6-bit
characters.  In LISP1.5, such words that are not used as two-pointer
cells are called _full word_.  A character string is represented
as a list of such full words.  (Though LISP1.5 didn't have a string
object -- list of full words only appears as an attribute value
of atomic symbols).

Distinguishing cons cells and full words are done by simply
splitting memory into regions; certain region only stores cons cells,
and another region only sotres full words.  So you can tell which is which
by looking at the address.

We don't really write an emulator of IBM704, but we can taste
its flavor by defining our memory as an array of words.

Let's use `u32vector` as our memory.  Our word is 32bit.  For a cell,
we read it as two 16bit addresses; so we have 65536 words.  So small, yeh?
It still amounts 256KB of memory and that was luxury back then.

To keep things simple, we split our 16bit address space into two even
spaces; first half for the cells, and second half for the full words.
Then we can look at the MSB of the address to say which is which.

----
                 32bit word
       +----------------------------+
#xffff |                            |
       |                            |
       |         Full words         |
       |                            |
#x8000 |                            |
       +----------------------------+
#x7fff |                            |
       |                            |
       |         Cons cells         |
       |                            |
#x0000 |                            |
       +----------------------------+
----       

A cons cell consists of two 16-bit addresses:

----
                      16bits         16bits
                 +--------------+--------------+
      Cons cell: |     CDR      |     CAR      |
                 +--------------+--------------+
----

A full word may be used for character strings, numbers (32bit signed
fixnum or 32bit single-precision floating number),
and native objects.

Character strings are a list of cells each of whose CDR points to a
full word, which can contain up to 8 octets, NUL-padded.  Character
strings are not first-class object in LISP1.5 and can only appear
as the name of symbols.

A native object is a backdoor for LISP1.5 programs to access
underlying Gauche features; certain primitive functions are
implemented in Gauche level, and called from LISP1.5 via native
objects.  It is simply a index to a native object vector.

Numbers and native objects are always pointed from CDR of a special cons
cell, whose CAR has a special value to distinguish itself from the ordinary
cons cells.  We use the following special values to _tag_ the special
cons cells.

* #xffff - The cell is a symbol, and its CDR has a property list.
* #xfffe - The cell is a native object, and its CDR is an index to
the native object vector.
* #xfffd - The cell is a fixnum, and its CDR points to a full word of
32bit signed integer.
* #xfffc - The cell is a flonum, and its CDR points to a full word of
32bit floating point number.

We reserve full words at these addresses, so that no valid pointer
can use these values.

[NOTE]
==================================================================
In original LISP1.5, an atom is a cell with -1 (#o77777) in its CAR.
An atom can be a symbol or a number.  The type of the atom is
distinguished by the tag field of the word.
==================================================================

=== Symbols




=== Allocator and garbage collector

We have `CONS` to allocate memory, but there's no operation to explicitly
free it.  Instead, we scan the memory and reclaim unused words when
needed.  LISP was the birthplace of garbage collection.

LISP1.5 used mark-and-sweep garbage collector.   For cons cells,
sign bit (in the prefix field) is used as a mark bit, and for full words,
separate bittable is used as mark bits.

In our architecture we don't have any extra bit, but we can
put extra piece of memory.  So, let's assume we have a special
kind of memory outside of the address space, where each bit
corresponds to each word in the main memory.  We'll provide
primitives to read and modify those bits.

Memory allocation works as follows:

* Initially, all the available cons cells and available full words
are chained to each _freelist_.  Each entry of the free list looks like
this (0 in the next word indicates the end of the list).

----
                      16bits         16bits
                 +--------------+--------------+
Free list entry: |      0       |  next word   |
                 +--------------+--------------+
----

* Every time we need a new cons cell or full word, we take one from
either freelist.  If we exhaust either one, we trigger GC.

Our garbage collector is a traditional mark-and-sweep GC:

* Clear the mark bits.
* From the root set, we trace all the pointers and mark the visited words.
* Scan the mark bits and push words that hasn't been marked to the freelist.

However, there's a catch -- our collector itself is written in LISP,
so it needs to allocate some memory

=== Standard library

=== Applications


