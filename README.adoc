// -*- coding: utf-8 -*-
= LISP1.5 implementation on Gauche
:sectnums:

This is a fun project to implement LISP 1.5 as described in
"LISP 1.5 Programmer's Manual".  It's not a complete LISP 1.5 environment
emulator; instead, it is to get a glimpse of how it is constructed.

:toc:

== M-expressions

Back then, M-expression was for human to write and read programs on paper,
but you had to manually translate it to S-expression then punch the cards.
Now you can make the computer understand M-expression directly!

=== M-expression syntax summary

- Identifiers are in all lowercase.  Literal symbols are in all uppercase.
  No `quote` in M-expression.  Literal list can be written using parentheses,
  e.g. `(A B (C D . E))`, without a quote.
- Function call is written as `fn[arg1;arg2;...]`
- Conditional is `[test1 \-> expr1; test2 \-> expr2;...]`.  It works just like
  `cond`.   Unicode arrow character `->` (U+2192) can be used in place of `\->`.
- Symbol `NIL` is used for list terminator.  Hence `cons[A;NIL]` yields
  `(A)`.
- Literal function is written as `lambda[[arg;..];expr]`.  This lambda form
itself doesn't have a value---it must be called with arguments to take effect.
- Local recursive function can be written as `label[name;lambda[[arg;...];expr]]`,
where you can use `name` in the `expr` to refer to itself.
- In toplevel, you can define a function by `name[arg;...] = expr`.

We also add this extension:

- A hash sign `#` to the end of line is a comment.  We avoid `;`, for
  it is used as a separator.


=== Calling M-expression parser

Module `LISP1.5.mexpr` implements parsers.  A procedure
`parse-mexpr` takes a string or an input port, and parses one M-expression
and returns an S-expression.

[source,console]
----
gosh> ,u LISP1.5.mexpr
gosh> (parse-mexpr "cons[(A . B);C]")
(CONS (QUOTE (A . B)) (QUOTE C))
----

Uppercase names and lists in M-expression are literals,
hence they are QUOTE-d once parsed.

If the input may contain more than one M-expression, use `parse-mexprs`
instead, which reads input up to EOF and returns an lseq of result
S-expressions.


=== Writing source in M-expression:

You can write M-expression in Scheme source code using `#!m-expr` directive.

[source,console]
----
;;
;; Scheme comments
;; 
(use LISP1.5.mexpr)
#!m-expr

# M-expression function definitions
function1[arg;...] = expression1
function2[arg;...] = expression2
...
----

The `#!m-expr` directive translates those M-expressions into
a LISP1.5 `DEFINE` form:

[source,lisp]
----
(DEFINE
 ((FUNCTION1 (LAMBDA (ARG ...) EXPRESSION1))
  (FUNCTION2 (LAMBDA (ARG ...) EXPRESSION2))
  ...))
----

Note that you have to have definitions of `DEFINE` and other primitive
LISP1.5 forms before loading the source file; The `LISP1.5.mexpr` module
only handles parsing.

We provide several implementations of those LISP1.5 primitives,
which we'll show you in the following chapters.


== A Universal LISP Function

=== Running EVAL with minimal axioms

Section 1.6 of "LISP 1.5 Programmier's Manual" is one of the pinnacles
of the document.  They show how to implement Lisp interpreter
on top of Lisp systems.  They call it a "Universal LISP function".

We write out their code in link:examples/eval.mx[].

What's interesting about it is that you only need a handful of
functions and syntaxes to run the interpreter.  We define those
minimal set of primitives in link:LISP1/5/axiom1.scm[].
It provides the definition of the following primitives:
`CAR`, `CDR`, `CONS`, `ATOM`, `EQ`, `QUOTE`, `COND`, and `DEFINE`.

To try the eval function, first `use` the axiom1 module, then
load the `eval.mx` file.  Assuming you have
load path set to the top directory of LISP1.5 source,
you can say the following in the gosh REPL:

[source,console]
----
gosh> ,u LISP1.5.axiom1
gosh> ,l examples/eval.mx
#t
----

Or, you can start gosh with loading necessary modules
(this assumes you're in the top directory of LISP1.5 source):

[source,console]
----
$ gosh -I. -u LISP1.5.axiom1 -l examples/eval.mx
----

On the gosh prompt, you can call `EVAL`.  The first argument
is the S-expression to evaluate, and the second argument
is the environment (assoc list of symbols and values):

[source,lisp]
----
gosh> (EVAL '(CONS (CAR (QUOTE (X . Y))) (QUOTE Z)) 'NIL)
(X . Z)
----

If you prefer, you can write M-expressions using
read-time constructor `#,(m-expr "...")`:

[source,lisp]
----
gosh> (EVAL '#,(m-expr "cons[car[(X . Y)];Z]") 'NIL)
(X . Z)
----

Following is a bit more convoluted example.  It defines `append`
as recursive funciton using `LABEL`, and calls it with
two arguments, `(A B C)` and `(X Y Z)`:


[source,lisp]
----
gosh> (EVAL '#,(m-expr "label[append;lambda[[xs;r];\
                               [eq[xs;NIL] -> r;\
                                T -> cons[car[xs];append[cdr[xs];r]]]]]\
                        [(A B C);(X Y Z)]")
            'NIL)
(A B C X Y Z)
----

This interpreter only "knows" the minimal 7 primitives:
`CAR`, `CDR`, `CONS`, `ATOM`, `EQ`, `QUOTE`, and `COND`.
To refer to anything other than that, 
you have to pass them as the environment argument.

The following example reverses a list, using the
definition of `NULL`, `APPEND` and `REVERSE` given to the environment:

[source,lisp]
----
gosh> (EVAL '#,(m-expr "reverse[(A B C D E F G)]")
            '((NULL . #,(m-expr "lambda[[x];[eq[x;NIL] -> T; T -> F]]"))
              (APPEND . #,(m-expr "lambda[[xs;r];\
                                     [eq[xs;NIL] -> r;\
                                      T -> cons[car[xs];append[cdr[xs];r]]]]"))
              (REVERSE . #,(m-expr "lambda[[xs];\
                                      [null[xs] -> NIL;\
                                       T -> append[reverse[cdr[xs]];cons[car[xs];NIL]]]]"))
             ))
(G F D C B A)
----

We need to give the function `NULL`, since the one defined in `eval.mx`
is not visible from the world of `EVAL`.

Hint: When you refer to an identifier that's neither one of the built-in
primitive nor the one given in the environment, you'll get an error
like the following:

[source]
----
*** ERROR: pair required, but got NIL
Stack Trace:
_______________________________________
  0  (car x)
        at "./LISP1/5/axiom1.scm":9
  1  (CAR X)
        [unknown location]
  2  (CAAR A)
        [unknown location]
  3  (EQUAL (CAAR A) X)
        [unknown location]
  4  (ASSOC E A)
        [unknown location]
  5  (EVAL FN A)
        [unknown location]
...
----

The code searches the environment alist by `ASSOC`, hits the end of
the alist without finding it and complains.  Remember, we have minimal
interpreter and there's no fancy error handling mechanism!


=== Going Metacircular

Since the universal LISP function defined in `eval.mx` understands
required primitives to interpret functions in `eval.mx`, you can use
our `EVAL` to evaluate `eval.mx` to run `EVAL` on top of 
`EVAL`--now you're running a metacircular interpreter!

You might have noticed though, that `axiom1.scm` provides `DEFINE`,
which is missing in `eval.mx`.  In our context of discussing
metacircular interpreter, `DEFINE` appears as a result of
parsing M-expression definitions, and should be understood
as a meta-language to direct the set-up, rather than an integrated
part of the language (one way to think of it is that if other primitives
are C built-ins then `DEFINE` is `#pragma` or `Makefile`---they belong
to a slightly different layer.)

Of course, it is more convenient to include `DEFINE` in the core language,
and we'll deal with it later.  For now, let's stick to the primitives
excluding `DEFINE`.

In order to run `EVAL` inside `EVAL`, we need to prepare the definitions
in `eval.mx` as an environment alist passed to outer `EVAL`.
Run the following command in the toplevel source directory:

[source, console]
----
$ gosh tools/axiom-env.scm examples/eval.mx
----

It reads `eval.mx` and prints the definitions in an alist.  Copy the output,
then start `gosh` again, read `axiom1` and load `eval.mx`, and evaluate
the `EVAL` expression, passing the copied alist as the environment
(don't forget the quote before the alist!):


[source, lisp]
----
gosh> ,u LISP1.5.axiom1
gosh> ,l examples/eval.mx
#t
gosh> (EVAL '(EVAL (QUOTE (CAR (QUOTE (X . Y)))) (QUOTE NIL))
            '...<<here, copy & paste the output of axiom-env.scm>>)
X
----

The result `X` is the result of `(QUOTE (CAR (QUOTE (X . Y))))`, computed
by the `EVAL` function implemented in LISP1.5, not the underlying Gauche.

If it is not obvious, try it with slightly different environment.
For example, edit the output of `axiom-env` so that it recognizes
`KAR` instead of `CAR` as the primitive:

[source, lisp]
----
 (APPLY
  LAMBDA
  (FN X A)
  (COND
   ((ATOM FN)
    (COND ((EQ FN (QUOTE KAR)) (CAAR X)) ((EQ FN (QUOTE CDR)) (CDAR X))
                         ^^^
----

(It is the only place you need to edit; other `CAR` in the environment
are recognized by the base `EVAL` so shouldn't be touched.)

Then, the inner `EVAL` understands `KAR` instead of `CAR`:

[source, lisp]
----
(EVAL '(EVAL (QUOTE (KAR (QUOTE (X . Y)))) (QUOTE NIL))
      '...<<paste the edited environment alist>>...)
 => X
----

