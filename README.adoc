// -*- coding: utf-8 -*-
= LISP1.5 implementation on Gauche

This is a fun project to implement LISP 1.5 as described in
``LISP 1.5 Programmer's Manual''.  It's not a complete LISP 1.5 environment
emulator; instead, it is to get a glimpse of how it is constructed.

It comes with a few components.

== M-expressions

Back then, M-expression was for human to write and read programs on paper,
but you had to manually translate it to S-expression then punch the cards.
Now you can make the computer understand M-expression directly!

An example can be found in link:examples/eval.mx[].

=== M-expression syntax summary

- Identifiers are in all lowercase.  Literal symbols are in all uppercase.
  No `quote` in M-expression.  Literal list can be written using parentheses,
  e.g. `(A B (C D . E))`, without a quote.
- Function call is written as `fn[arg1;arg2;...]`
- Conditional is `[test1 \-> expr1; test2 \-> expr2;...]`.  It works just like
  `cond`.   Unicode arrow character `->` (U+2192) can be used in place of `\->`.
- Symbol `NIL` is used for list terminator.  Hence `cons[A;NIL]` yields
  `(A)`.
- Literal function is written as `lambda[[arg;..];expr]`.
- Local recursive function can be written as `label[name;expr]`, where
  you can use `name` in the `expr` to refer to itself.
- In toplevel, you can define a function by `name[arg;...] = expr`.

We also add this extension:

- A hash sign `#` to the end of line is a comment.  We avoid `;`, for
  it is used as a separator.


=== Calling M-expression parser

Module `LISP1.5.mexpr` implements parsers.  A procedure
`parse-mexpr` takes a string or an input port, and parses one M-expression
and returns an S-expression.

[source,console]
----
gosh> ,u LISP1.5.mexpr
gosh> (parse-mexpr "cons[(A . B);C]")
(CONS (QUOTE (A . B)) (QUOTE C))
----

Note that uppercase names and lists in M-expression are literals,
hence QUOTEd once parsed.

If the input can contain more than one M-expression, use `parse-mexprs`
instead, which reads input up to EOF and returns an lseq of result
S-expressions.


=== Writing source in M-expression:

You can write M-expression in Scheme source code using `#!m-expr` directive.

[source,console]
----
;;
;; Scheme comments
;; 
(use LISP1.5.mexpr)
#!m-expr

# M-expression function definitions
function1[arg;...] = expression1
function2[arg;...] = expression2
...
----

The `#!m-expr` directive translates those M-expressions into
a LISP1.5 `DEFINE` form:

[source,lisp]
----
(DEFINE
 ((FUNCTION1 (LAMBDA (ARG ...) EXPRESSION1))
  (FUNCTION2 (LAMBDA (ARG ...) EXPRESSION2))
  ...))
----

Note that you have definitions of `DEFINE` and other primitive
LISP1.5 forms before loading the source file; The `LISP1.5.mexpr` module
only handles parsing.

We provide several implementations of those LISP1.5 primitives,
which we'll show you in the following chapters.


== Minimal system and a universal LISP function

Section 1.6 of "LISP 1.5 Programmier's Manual" is one of the pinnacles
of the document.  They show how to implement Lisp interpreter
on top of Lisp systems.  They call it a "Universal LISP function".

We write out their code in link:examples/eval.mx[].

What's interesting about it is that you only need a handful of
functions and syntaxes to run the interpreter.  We define those
minimal set of primitives in link:LISP1.5.axiom1.scm[].

To try the eval function, first `use` the axiom1 module, then
load the `eval.mx` file.  Assuming you have
load path set to the top directory of LISP1.5 source,
you can say the following in the gosh REPL:

[source,console]
----
gosh> ,u LISP1.5.axiom1
gosh> ,l examples/eval.mx
#t
----

Or, you can start gosh with loading necessary modules
(this assumes you're in the top directory of LISP1.5 source):

[source,console]
----
$ gosh -I. -u LISP1.5.axiom1 -l examples/eval.mx
----

On the gosh prompt, you can call `EVAL`.  The first argument
is the S-expression to evaluate, and the second argument
is the environment (assoc list of symbols and values):

[source,lisp]
----
gosh> (EVAL '(CONS (CAR (QUOTE (X . Y))) (QUOTE Z)) 'NIL)
(X . Z)
----

If you prefer, you can write M-expressions using
read-time constructor `#,(m-expr "...")`:

[source,lisp]
----
gosh> (EVAL '#,(m-expr "cons[car[(X . Y)];Z]") 'NIL)
(X . Z)
----

